<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>灯泡</title>
      <link href="/2021/08/21/leetcode/%E7%81%AF%E6%B3%A1/"/>
      <url>/2021/08/21/leetcode/%E7%81%AF%E6%B3%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="319-灯泡开关"><a href="#319-灯泡开关" class="headerlink" title="319. 灯泡开关"></a><a href="https://leetcode-cn.com/problems/bulb-switcher/">319. 灯泡开关</a></h1><p>初始时有 n 个灯泡处于关闭状态。</p><p>对某个灯泡切换开关意味着：如果灯泡状态为关闭，那该灯泡就会被开启；而灯泡状态为开启，那该灯泡就会被关闭。</p><p>第 1 轮，每个灯泡切换一次开关。即，打开所有的灯泡。</p><p>第 2 轮，每两个灯泡切换一次开关。 即，每两个灯泡关闭一个。</p><p>第 3 轮，每三个灯泡切换一次开关。</p><p>第 i 轮，每 i 个灯泡切换一次开关。 而第 n 轮，你只切换最后一个灯泡的开关。</p><p>找出 n 轮后有多少个亮着的灯泡。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>现有 nn 盏灯编号为1,2,\cdots,n1,2,⋯,n，按题意理解共存在 nn 轮调整。模拟自然是一种角度（会超时）；不妨换一个角度，考察单盏灯。请看示例：</p><p>示例11：对于 1010 号灯，在第 1,2,5,101,2,5,10 轮会进行调整；<br>示例22：对于 1616 号灯，在第 1,2,4,8,161,2,4,8,16 轮会进行调整；<br>\qquad从以上两个例子可以看出，第 ii 盏灯会在它全部的因数处发生调整；进一步地，我们并不关心因数具体值，关心的是因数的总数。我们发现：「若存在奇数个因数，对应调整奇数次，最后保持亮灯；否则灯灭。」问题转换——求在区间 [1, n][1,n] 上，因数总数为奇数的数字个数。<br>\qquad非常遗憾，如果你不知道下面的这个结论，即使思考到此处依然不能够顺利解题。</p><p>完全平方数的因数个数是奇数，非完全平方数因数个数为偶数。</p><p>\qquad简单证明：对于数值 xx ，按对来统计因数。例如 10=1\times10=2\times510=1×10=2×5 ，两对 44 个；再例如 16=1\times16=2\times8=4\times416=1×16=2×8=4×4 ，三对却是 55 个，因为因数 44 只可以统计 11 次。意会一下，证毕。</p><p>作者：<a href="https://leetcode-cn.com/problems/bulb-switcher/solution/319deng-pao-kai-guan-by-loveyuchuwei-133e/">LoveYuChuWei</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=(<span class="keyword">int</span>)Math.sqrt(n);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="672-灯泡开关-Ⅱ"><a href="#672-灯泡开关-Ⅱ" class="headerlink" title="672. 灯泡开关 Ⅱ"></a><a href="https://leetcode-cn.com/problems/bulb-switcher-ii/">672. 灯泡开关 Ⅱ</a></h1><p>现有一个房间，墙上挂有 n 只已经打开的灯泡和 4 个按钮。在进行了 m 次未知操作后，你需要返回这 n 只灯泡可能有多少种不同的状态。</p><p>假设这 n 只灯泡被编号为 [1, 2, 3 …, n]，这 4 个按钮的功能如下：</p><p>a.将所有灯泡的状态反转（即开变为关，关变为开）<br>b.将编号为偶数的灯泡的状态反转<br>c.将编号为奇数的灯泡的状态反转<br>d.将编号为 3k+1 的灯泡的状态反转（k = 0, 1, 2, …)</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>每6个状态的灯是一样的,所以只要看前6个灯有多少个状态就可以了</p><p>用abcd分别代表其操作次数   </p><pre><code>Light 1 = (1 + a + c + d)%2Light 2 = (1 + a + b)%2Light 3 = (1 + a + c)%2Light 4 = (1 + a + b + d)%2Light 5 = (1 + a + c)%2Light 6 = (1 + a + b)%2</code></pre><p>5,6灯分别和3,2灯的状态是一样的,所以只要看前面四个灯有几种状态即可   </p><p>又因为第四盏灯可以由前三盏灯决定,证明如下:</p><pre><code>Light 1 = (1 + a + c + d)%2Light 2 = (1 + a + b)%2Light 3 = (1 + a + c)%2Light 4 = (1 + a + b + d)%2</code></pre><p>前四盏灯的状态如上</p><ul><li>当Light 1== Light 3,d是偶数,则Light 2==Light 4</li><li>当Light 1!= Light 3,d是奇数,则Light 2!=Light 4</li></ul><p>所以前三个灯的状态就可以决定所有灯泡的状态</p><p>然后自己写一下,推一下前几种的情况就可以得出表了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">flipLights</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> presses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] res = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>&#125;,&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(presses==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(presses&lt;=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> res[presses][n&lt;<span class="number">3</span>?n:<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> res[presses&lt;<span class="number">3</span>?presses:<span class="number">3</span>][n&lt;<span class="number">3</span>?n:<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1375-灯泡开关-III"><a href="#1375-灯泡开关-III" class="headerlink" title="1375. 灯泡开关 III"></a><a href="https://leetcode-cn.com/problems/bulb-switcher-iii/">1375. 灯泡开关 III</a></h1><p>房间中有 n 枚灯泡，编号从 1 到 n，自左向右排成一排。最初，所有的灯都是关着的。</p><p>在 k  时刻（ k 的取值范围是 0 到 n - 1），我们打开 light[k] 这个灯。</p><p>灯的颜色要想 变成蓝色 就必须同时满足下面两个条件：</p><p>灯处于打开状态。<br>排在它之前（左侧）的所有灯也都处于打开状态。<br>请返回能够让 所有开着的 灯都 变成蓝色 的时刻 数目 。</p><p>示例 1 :</p><p>输入：light = [2,1,3,5,4]<br>输出：3<br>解释：所有开着的灯都变蓝的时刻分别是 1，2 和 4 。<br>示例 2：</p><p>输入：light = [3,2,4,1,5]<br>输出：2<br>解释：所有开着的灯都变蓝的时刻分别是 3 和 4（index-0）。<br>示例 3：</p><p>输入：light = [4,1,2,3]<br>输出：1<br>解释：所有开着的灯都变蓝的时刻是 3（index-0）。<br>第 4 个灯在时刻 3 变蓝。<br>示例 4：</p><p>输入：light = [2,1,4,3,6,5]<br>输出：3<br>示例 5：</p><p>输入：light = [1,2,3,4,5,6]<br>输出：6 </p><p>提示：</p><p>n == light.length<br>1 &lt;= n &lt;= 5 * 10^4<br>light 是 [1, 2, …, n] 的一个排列。</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>遍历数组，记录当前最大亮起来的灯，如果最大亮起来的灯等于遍历过的灯的数量，那么说明前面灯都亮了。举个例子，[2,1,3]，当遍历到3的时候，最大的灯是3，等于当前已经亮起来的灯的个数，因此3左侧的灯全部亮了，算一个可行解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTimesAllBlue</span><span class="params">(<span class="keyword">int</span>[] light)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; light.length; i++) &#123;</span><br><span class="line">max=Math.max(max, light[i]);</span><br><span class="line"><span class="keyword">if</span>(max==i+<span class="number">1</span>)</span><br><span class="line">c++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1529-灯泡开关-IV"><a href="#1529-灯泡开关-IV" class="headerlink" title="1529. 灯泡开关 IV"></a><a href="https://leetcode-cn.com/problems/bulb-switcher-iv/">1529. 灯泡开关 IV</a></h1><p>房间中有 n 个灯泡，编号从 0 到 n-1 ，自左向右排成一行。最开始的时候，所有的灯泡都是 关 着的。</p><p>请你设法使得灯泡的开关状态和 target 描述的状态一致，其中 target[i] 等于 1 第 i 个灯泡是开着的，等于 0 意味着第 i 个灯是关着的。</p><p>有一个开关可以用于翻转灯泡的状态，翻转操作定义如下：</p><p>选择当前配置下的任意一个灯泡（下标为 i ）<br>翻转下标从 i 到 n-1 的每个灯泡<br>翻转时，如果灯泡的状态为 0 就变为 1，为 1 就变为 0 。</p><p>返回达成 target 描述的状态所需的 最少 翻转次数。</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>从前往后模拟一遍就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch[] = target.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> cur=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(ch[i]!=cur)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">cur=cur==<span class="string">&#x27;1&#x27;</span>?<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="683-K-个关闭的灯泡"><a href="#683-K-个关闭的灯泡" class="headerlink" title="683. K 个关闭的灯泡"></a><a href="https://leetcode-cn.com/problems/k-empty-slots/">683. K 个关闭的灯泡</a></h1><p>N 个灯泡排成一行，编号从 1 到 N 。最初，所有灯泡都关闭。每天只打开一个灯泡，直到 N 天后所有灯泡都打开。</p><p>给你一个长度为 N 的灯泡数组 blubs ，其中 bulls[i] = x 意味着在第 (i+1) 天，我们会把在位置 x 的灯泡打开，其中 i 从 0 开始，x 从 1 开始。</p><p>给你一个整数 K ，请你输出在第几天恰好有两个打开的灯泡，使得它们中间 正好 有 K 个灯泡且这些灯泡 全部是关闭的 。</p><p>如果不存在这种情况，返回 -1 。如果有多天都出现这种情况，请返回 最小的天数 。</p><p> </p><p>示例 1：</p><p>输入：<br>bulbs: [1,3,2]<br>K: 1<br>输出：2<br>解释：<br>第一天 bulbs[0] = 1，打开第一个灯泡 [1,0,0]<br>第二天 bulbs[1] = 3，打开第三个灯泡 [1,0,1]<br>第三天 bulbs[2] = 2，打开第二个灯泡 [1,1,1]<br>返回2，因为在第二天，两个打开的灯泡之间恰好有一个关闭的灯泡。<br>示例 2：</p><p>输入：<br>bulbs: [1,2,3]<br>k: 1<br>输出：-1 </p><p>提示：</p><p>1 &lt;= N &lt;= 20000<br>1 &lt;= bulbs[i] &lt;= N<br>bulbs 是一个由从 1 到 N 的数字构成的排列<br>0 &lt;= K &lt;= 20000<br>通过次数2,061提交次数4,820</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kEmptySlots</span><span class="params">(<span class="keyword">int</span>[] bulbs, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> res=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bulbs.length; i++) &#123;</span><br><span class="line">set.add(bulbs[i]);</span><br><span class="line"><span class="keyword">if</span>(set.lower(bulbs[i])!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(bulbs[i]-set.lower(bulbs[i])==k+<span class="number">1</span>)</span><br><span class="line">&#123;res=i+<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(set.higher(bulbs[i])!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(set.higher(bulbs[i])-bulbs[i]==k+<span class="number">1</span>)</span><br><span class="line">&#123;res=i+<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2021/08/21/little_thing/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2021/08/21/little_thing/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,z,x,y,fa[<span class="number">10005</span>];<span class="comment">//fa[i]是第i号节点的祖先</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=fa[x]) x=fa[x]=fa[fa[x]];</span><br><span class="line">    <span class="comment">//让x和x的父亲变成他的父亲的父亲</span></span><br><span class="line">    <span class="comment">//直到找到祖先才结束循环(x==fa[x])就意味着找到爹了</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环版找爹函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//再附上递归版本的找爹函数</span></span><br><span class="line"><span class="comment">inline int find(int x) </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if (x==fa[x]) return x;</span></span><br><span class="line"><span class="comment">    //不停的递归查找</span></span><br><span class="line"><span class="comment">    return fa[x]=find(fa[x]);</span></span><br><span class="line"><span class="comment">    //路径压缩，可以缩短时间</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">    &#123;</span><br><span class="line">    fa[i]=i;</span><br><span class="line">        <span class="comment">//并查集的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;z&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">find</span>(x),b=<span class="built_in">find</span>(y);</span><br><span class="line">        <span class="comment">//ab分别去找自己的爹</span></span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        fa[a]=b;</span><br><span class="line">            <span class="comment">//并查集的合并操作，及将x点祖先的爹记为y点的祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a==b) </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">                <span class="comment">//爹一样就说明X与Y是在同一集合内，输出Y</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;N&quot;</span>);</span><br><span class="line">                <span class="comment">//否则就说明X与Y是在同一集合内，输出N</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> little_thing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XTU  1390. 字母计数</title>
      <link href="/2021/08/19/xtuoj/1390%E5%AD%97%E6%AF%8D%E8%AE%A1%E6%95%B0/"/>
      <url>/2021/08/19/xtuoj/1390%E5%AD%97%E6%AF%8D%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1390字母计数"><a href="#1390字母计数" class="headerlink" title="1390字母计数"></a><a href="http://202.197.224.59/exam/index.php/problem/read/id/1390">1390字母计数</a></h1><p>字母计数<br>题目描述<br>为了压缩一个只含小写英文字母的字符串，我们使用下面的方式表示它</p><p>任一字母c是表达式<br>任一字母c后接一个整数n也是一个表达式，表示把字母c重复n次，n是一个没有前导零的10进制整数，且 n≥2。<br>如果s1,s2是表达式，那么s1s2也是表达式。<br>S是一个表达式，那么(S)n也是表达式，表示将S这个表达式表示的字符串重复n次，n是一个没有前导零的10进制整数，且 n≥2。<br>比如表达式 ((a2b)2b)2a 表示字符串aabaabbaabaabba。</p><p>现在给你一个表达式，请统计一下其中各个字符出现的次数。</p><p>输入<br>存在多组样例，每样一个样例，为一个字符串。 字符串只含小写英文字母，数字和括号，其长度不超过50个字符，输入数据保证符合表达式要求，且展开后的字符出现次数最高不超过109。</p><p>输出<br>依次输出每个样例的结果。 每个样例按照字母顺序，每个出现的字母输出一行。格式为”c : n”,其中c为字母，n为出现的次数。 每个样例之后输出一个空行。</p><p>样例输入<br>((a2b)2b)2a<br>a2c3<br>样例输出<br>a : 9<br>b : 6</p><p>a : 2<br>c : 3</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String s= in.next();</span><br><span class="line">            <span class="keyword">int</span> res[]=get(s);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> ch=(<span class="keyword">char</span>)(i+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(res[i]!=<span class="number">0</span>)</span><br><span class="line">                    System.out.println(ch+<span class="string">&quot; : &quot;</span>+res[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] get(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span> res[]= <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre&lt;s.length()&amp;&amp;s.charAt(pre)!=<span class="string">&#x27;(&#x27;</span>)pre++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l--;</span><br><span class="line">                <span class="keyword">if</span>(l==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> a[]= <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">26</span>];</span><br><span class="line">                         </span><br><span class="line">                        String kk=s.substring(pre+<span class="number">1</span>,i);</span><br><span class="line">                        a=get(kk);</span><br><span class="line">                        <span class="keyword">if</span>(i&lt;s.length()-<span class="number">1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">char</span> q=s.charAt(i+<span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">int</span> t=i+<span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">if</span>(Character.isDigit(q))</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">while</span>(t&lt;s.length()&amp;&amp;Character.isDigit(s.charAt(t)))</span><br><span class="line">                                &#123;</span><br><span class="line">                                    num=num*<span class="number">10</span>+(<span class="keyword">int</span>)(s.charAt(t)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                                    t++;</span><br><span class="line">                                &#125;</span><br><span class="line">                                i=t-<span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                                    a[j]*=num;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">int</span> t=i;</span><br><span class="line">                        <span class="keyword">while</span>(t&lt;s.length()&amp;&amp;s.charAt(t)!=<span class="string">&#x27;(&#x27;</span>)t++;</span><br><span class="line">                        pre=t;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                            res[j]+=a[j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Character.isLetter(ch)&amp;&amp;l==<span class="number">0</span>)</span><br><span class="line">                res[ch-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(Character.isDigit(ch)&amp;&amp;l==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> q=s.charAt(i-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(Character.isLetter(q))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span>(i&lt;s.length()&amp;&amp;Character.isDigit(s.charAt(i)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        num=num*<span class="number">10</span>+(<span class="keyword">int</span>)(s.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i--;</span><br><span class="line">                    res[q-<span class="string">&#x27;a&#x27;</span>]+=num-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> xtuoj </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xtuoj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XTU 1264. 字符不重复子串</title>
      <link href="/2021/08/18/xtuoj/1264%E5%AD%97%E7%AC%A6%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/"/>
      <url>/2021/08/18/xtuoj/1264%E5%AD%97%E7%AC%A6%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1264-字符不重复子串"><a href="#1264-字符不重复子串" class="headerlink" title="1264. 字符不重复子串"></a><a href="http://202.197.224.59/exam/index.php/problem/read/id/1264">1264. 字符不重复子串</a></h1><p>给一个只含英文小写的字符串，求其最长的字符不重复的子串。比如字符串”abcabc”，最长字符不重复子串长度为3，最长字符不重复子串为”abc”,”bca”,”cab”；字符串”aaaaa”，最长字符不重复子串长度为1，字符串为”a”。</p><p>输入<br>存在多个样例，每行输入一个字符串，串长不超过10000。</p><p>输出<br>每个样例先输出最长的字符不重复子串的长度，然后按字典序输出这些不重复子串，每个子串输出一行。</p><p>样例输入<br>abcabc<br>aaaaa<br>样例输出<br>3<br>abc<br>bca<br>cab<br>1<br>a</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>先将每个字符出现的位置用hashmap记录下来,为了便于后续查找,使用treeset来记录同一个字符出现的不同位置</li><li>定义dp[i]为以第i个字符为后缀的最长的长度(刚开始我是直接用的同一个字符的两个不同位置作为差值,没考虑到可能两个位置之间还有重复字符出现的问题,经过改进后有<code>dp[i]=Math.min(dp[i-1]+1, dp[i]);</code>)</li><li>遍历dp[i],将符合条件的String放入treeset中,然后输出.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">w1264</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Scanner  in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(in.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">s=in.next();</span><br><span class="line">HashMap&lt;Character,TreeSet&lt;Integer&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;Character, TreeSet&lt;Integer&gt;&gt;();</span><br><span class="line"><span class="keyword">char</span> [] ch = s.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">TreeSet&lt;Integer&gt; t=map.getOrDefault(ch[i], <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line">t.add(i);</span><br><span class="line">map.put(ch[i],t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span> [ch.length];</span><br><span class="line"><span class="keyword">int</span> max=-<span class="number">1</span>;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">TreeSet&lt;Integer&gt; t=map.get(ch[i]);</span><br><span class="line">dp[i]= t.lower(i)==<span class="keyword">null</span> ?i+<span class="number">1</span>:i-t.lower(i);</span><br><span class="line">dp[i]=Math.min(dp[i-<span class="number">1</span>]+<span class="number">1</span>, dp[i]);</span><br><span class="line">max=Math.max(max, dp[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">TreeSet&lt;String&gt; set= <span class="keyword">new</span> TreeSet&lt;String&gt;((a,b)-&gt;a.compareTo(b));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i]==max)</span><br><span class="line">set.add(s.substring(i-max+<span class="number">1</span>,i+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(max);</span><br><span class="line"><span class="keyword">for</span> (String string : set) &#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> xtuoj </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xtuoj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>552. 学生出勤记录 II</title>
      <link href="/2021/08/18/leetcode/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/08/18/leetcode/%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="552-学生出勤记录-II"><a href="#552-学生出勤记录-II" class="headerlink" title="552. 学生出勤记录 II"></a><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/">552. 学生出勤记录 II</a></h1><p>可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：<br>‘A’：Absent，缺勤<br>‘L’：Late，迟到<br>‘P’：Present，到场<br>如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：</p><p>按 总出勤 计，学生缺勤（’A’）严格 少于两天。<br>学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（’L’）记录。<br>给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。</p><p>示例 1：</p><p>输入：n = 2<br>输出：8<br>解释：<br>有 8 种长度为 2 的记录将被视为可奖励：<br>“PP” , “AP”, “PA”, “LP”, “PL”, “AL”, “LA”, “LL”<br>只有”AA”不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。<br>示例 2：</p><p>输入：n = 1<br>输出：3<br>示例 3：</p><p>输入：n = 10101<br>输出：183236316</p><p>提示：</p><p>1 &lt;= n &lt;= 105</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>状态定义：dp[i][j][k]表示第 i 天、在 A 为 j 次、连续的 L 为 k 次的方案数。<br>状态转移：所有的状态都是从前一天，即 i-1，转移而来，但是对于 j 和 k，要分三种情况来讨论：</p><ul><li>当前填入的是 P，i-1 天的任何状态都能转移过来；</li><li>当前填入的是 A，i-1 天即之前肯定没填过 A，同时所有的 late 状态都可以转移到过来。</li><li>当前填入的是 L，i-1 天最多只能有一个连续的 L，其他的状态依次转移过来。</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkRecord</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> [][] pre =<span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    pre[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    pre[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    pre[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">int</span> mod=  <span class="number">1000000007</span>;<span class="comment">//踩坑2,1e9+7 ,之前写的是10e9+7</span></span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;<span class="keyword">long</span> [][] now =<span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    now[<span class="number">1</span>][<span class="number">0</span>]=(pre[<span class="number">0</span>][<span class="number">0</span>]+pre[<span class="number">0</span>][<span class="number">1</span>]+pre[<span class="number">0</span>][<span class="number">2</span>])%mod;</span><br><span class="line">    now[<span class="number">1</span>][<span class="number">0</span>]=(now[<span class="number">1</span>][<span class="number">0</span>]+pre[<span class="number">1</span>][<span class="number">0</span>]+pre[<span class="number">1</span>][<span class="number">1</span>]+pre[<span class="number">1</span>][<span class="number">2</span>])%mod;</span><br><span class="line">    now[<span class="number">0</span>][<span class="number">0</span>]=(pre[<span class="number">0</span>][<span class="number">0</span>]+pre[<span class="number">0</span>][<span class="number">1</span>]+pre[<span class="number">0</span>][<span class="number">2</span>])%mod;</span><br><span class="line">    now[<span class="number">0</span>][<span class="number">1</span>]= pre[<span class="number">0</span>][<span class="number">0</span>] ;</span><br><span class="line">    now[<span class="number">0</span>][<span class="number">2</span>]= pre[<span class="number">0</span>][<span class="number">1</span>]  ;</span><br><span class="line">    now[<span class="number">1</span>][<span class="number">1</span>]= pre[<span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line">    now[<span class="number">1</span>][<span class="number">2</span>]= pre[<span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line">    pre=now.clone();<span class="comment">//传的是引用,踩坑1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">3</span>; j++) &#123;</span><br><span class="line">sum=(sum+pre[i][j])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3的最大倍数</title>
      <link href="/2021/08/16/leetcode/3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%8D%E6%95%B0/"/>
      <url>/2021/08/16/leetcode/3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1363-形成三的最大倍数"><a href="#1363-形成三的最大倍数" class="headerlink" title="1363. 形成三的最大倍数"></a><a href="https://leetcode-cn.com/problems/largest-multiple-of-three/">1363. 形成三的最大倍数</a></h1><p>给你一个整数数组 digits，你可以通过按任意顺序连接其中某些数字来形成 3 的倍数，请你返回所能得到的最大的 3 的倍数。</p><p>由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。</p><p>如果无法得到答案，请返回一个空字符串。</p><p>示例 1：</p><p>输入：digits = [8,1,9]<br>输出：”981”<br>示例 2：</p><p>输入：digits = [8,6,7,1,0]<br>输出：”8760”<br>示例 3：</p><p>输入：digits = [1]<br>输出：””<br>示例 4：</p><p>输入：digits = [0,0,0,0,0,0]<br>输出：”0”</p><p>提示：</p><p>1 &lt;= digits.length &lt;= 10^4<br>0 &lt;= digits[i] &lt;= 9<br>返回的结果不应包含不必要的前导零。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>统计数组的和sum,以及取余3等于1,2的个数<br>看sum%3的结果<br>如果是1:就删除模3==1的一个数或模3==2的两个数,若没有则返回””；<br>如果是2:同理可得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">largestMultipleOfThree</span><span class="params">(<span class="keyword">int</span>[] digits)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> l1 = <span class="number">0</span>, l2 = <span class="number">0</span>, l3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digits.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> r = digits[i] % <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">1</span>) &#123;</span><br><span class="line">l1++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">2</span>) &#123;</span><br><span class="line">l2++;</span><br><span class="line">&#125;</span><br><span class="line">s[digits[i]]++;</span><br><span class="line">sum += digits[i];</span><br><span class="line">l3++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r = sum % <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l1 &gt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i = i + <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] != <span class="number">0</span>) &#123;</span><br><span class="line">s[i]--;</span><br><span class="line">l3--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l2 &gt;= <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;<span class="number">10</span>; i = i + <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (s[i] != <span class="number">0</span>) &#123;<span class="comment">//这里之前错了，之前用的if</span></span><br><span class="line">s[i]--;</span><br><span class="line">c++;</span><br><span class="line">l3--;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l2 &gt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; i = i + <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] != <span class="number">0</span>) &#123;</span><br><span class="line">s[i]--;</span><br><span class="line">l3--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l1&gt;= <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;<span class="number">10</span>; i = i + <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(s[i] != <span class="number">0</span>) &#123;</span><br><span class="line">s[i]--;</span><br><span class="line">l3--;</span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l3 == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">StringBuilder q = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; q.length() == <span class="number">0</span> &amp;&amp; s[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i]; j++) &#123;</span><br><span class="line">q.append((<span class="keyword">char</span>)(i + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(q);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元素不等于两相邻元素平均值的数组</title>
      <link href="/2021/08/15/leetcode/%E5%85%83%E7%B4%A0%E4%B8%8D%E7%AD%89%E4%BA%8E%E4%B8%A4%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%B9%B3%E5%9D%87%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84/"/>
      <url>/2021/08/15/leetcode/%E5%85%83%E7%B4%A0%E4%B8%8D%E7%AD%89%E4%BA%8E%E4%B8%A4%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%B9%B3%E5%9D%87%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="5832-构造元素不等于两相邻元素平均值的数组"><a href="#5832-构造元素不等于两相邻元素平均值的数组" class="headerlink" title="5832. 构造元素不等于两相邻元素平均值的数组"></a><a href="https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors/">5832. 构造元素不等于两相邻元素平均值的数组</a></h1><p>给你一个 下标从 0 开始 的数组 nums ，数组由若干 互不相同的 整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都 不等于 其两侧相邻元素的 平均值 。</p><p>更公式化的说法是，重新排列的数组应当满足这一属性：对于范围 1 &lt;= i &lt; nums.length - 1 中的每个 i ，(nums[i-1] + nums[i+1]) / 2 不等于 nums[i] 均成立 。</p><p>返回满足题意的任一重排结果。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p> 数组排序后分成两部分<br> 前半部分小的放偶数位,后半部分大的放奇数位</p><p> 第一部分的任何一个元素一定小于第二部分的任意一个元素。这也意味着，第一部分任意两个元素的平均值一定不会等于第二部分的任意一个元素，反之亦然。</p><p> 元素是互不相同的<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] rearrangeArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> res[]= <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i=i+<span class="number">2</span>) &#123;</span><br><span class="line">res[i]=nums[j++];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.length; i=i+<span class="number">2</span>) &#123;</span><br><span class="line">    res[i]=nums[j++];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2021/08/15/little_thing/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2021/08/15/little_thing/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p><a href="https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/">参考资料</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> || x == <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0.0</span>) <span class="keyword">return</span> <span class="number">0.0d</span>;</span><br><span class="line"><span class="keyword">long</span> b = n;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Java 代码中 int32 变量 n \in [-2147483648, 2147483647]n∈[−2147483648,2147483647]</span></span><br><span class="line"><span class="comment"> * ，因此当 n = -2147483648n=−2147483648 时执行 n = -n 会因越界而赋值出错。解决方法是先将</span></span><br><span class="line"><span class="comment"> *  nn 存入 long 变量bb ，后面用 bb 操作即可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (b&lt; <span class="number">0</span>) &#123;</span><br><span class="line">x = <span class="number">1</span> / x;<span class="comment">//x==0处理</span></span><br><span class="line">b = -b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">res *= x;</span><br><span class="line">x *= x;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="取模迭代"><a href="#取模迭代" class="headerlink" title="取模迭代"></a>取模迭代</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">long</span> <span class="title">Pow_mid</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>   ans=<span class="number">1l</span>;</span><br><span class="line">        a=a%c;</span><br><span class="line">        <span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((b&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">                ans=(ans*a)%c;</span><br><span class="line">            a=(a*a)%c;</span><br><span class="line">            b=b&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> little_thing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不高兴的朋友</title>
      <link href="/2021/08/14/leetcode/%E4%B8%8D%E9%AB%98%E5%85%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/"/>
      <url>/2021/08/14/leetcode/%E4%B8%8D%E9%AB%98%E5%85%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1583-统计不开心的朋友"><a href="#1583-统计不开心的朋友" class="headerlink" title="1583. 统计不开心的朋友"></a><a href="https://leetcode-cn.com/problems/count-unhappy-friends/">1583. 统计不开心的朋友</a></h1><p>给你一份 n 位朋友的亲近程度列表，其中 n 总是 偶数 。</p><p>对每位朋友 i，preferences[i] 包含一份 按亲近程度从高到低排列 的朋友列表。换句话说，排在列表前面的朋友与 i 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 0 到 n-1 之间的整数表示。</p><p>所有的朋友被分成几对，配对情况以列表 pairs 给出，其中 pairs[i] = [xi, yi] 表示 xi 与 yi 配对，且 yi 与 xi 配对。</p><p>但是，这样的配对情况可能会是其中部分朋友感到不开心。在 x 与 y 配对且 u 与 v 配对的情况下，如果同时满足下述两个条件，x 就会不开心：</p><p>x 与 u 的亲近程度胜过 x 与 y，且<br>u 与 x 的亲近程度胜过 u 与 v<br>返回 不开心的朋友的数目 。</p><p>示例 1：</p><p>输入：n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]<br>输出：2<br>解释：<br>朋友 1 不开心，因为：</p><ul><li>1 与 0 配对，但 1 与 3 的亲近程度比 1 与 0 高，且</li><li>3 与 1 的亲近程度比 3 与 2 高。<br>朋友 3 不开心，因为：</li><li>3 与 2 配对，但 3 与 1 的亲近程度比 3 与 2 高，且</li><li>1 与 3 的亲近程度比 1 与 0 高。<br>朋友 0 和 2 都是开心的。  </li></ul><p>示例 2：</p><p>输入：n = 2, preferences = [[1], [0]], pairs = [[1, 0]]<br>输出：0<br>解释：朋友 0 和 1 都开心。</p><p>示例 3：</p><p>输入：n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]<br>输出：4</p><p>提示：</p><pre><code>2 &lt;= n &lt;= 500n 是偶数preferences.length == npreferences[i].length == n - 10 &lt;= preferences[i][j] &lt;= n - 1preferences[i] 不包含 ipreferences[i] 中的所有值都是独一无二的pairs.length == n/2pairs[i].length == 2xi != yi0 &lt;= xi, yi &lt;= n - 1每位朋友都 恰好 被包含在一对中</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>共有 nn 位朋友，每位朋友都对应一个其余 n-1n−1 位朋友的亲近程度从高到低排列的朋友列表，列表中的下标越小的朋友亲近程度越高。</p><p>题目已经给出了二维数组 \textit{preferences}preferences 表示每位朋友对应的按亲近程度从高到低排列的朋友列表，但是并没有直接给出其余 n-1n−1 位朋友对应的亲近程度下标，因此需要进行预处理，存储每位朋友的其余 n-1n−1 位朋友对应的亲近程度下标。</p><p>具体而言，创建 nn 行 nn 列的二维数组 \textit{order}order，其中 \textit{order}[i][j]order[i][j] 表示朋友 jj 在 ii 的朋友列表中的亲近程度下标。遍历 \textit{preferences}preferences 即可填入 \textit{order}order 中的全部元素的值。</p><p>所有的朋友被分成 \frac{n}{2}<br>2<br>n<br>​<br>  对，为了快速知道每位朋友的配对的朋友，对于配对情况也需要进行预处理。创建长度为 nn 的数组 \textit{match}match，如果 xx 和 yy 配对，则有 \textit{match}[x]=ymatch[x]=y 以及 \textit{match}[y]=xmatch[y]=x。</p><p>进行预处理之后，即可统计不开心的朋友的数目。</p><p>作者：<a href="https://leetcode-cn.com/problems/count-unhappy-friends/solution/tong-ji-bu-kai-xin-de-peng-you-by-leetcode-solutio/">LeetCode-Solution</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">unhappyFriends</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] preferences, <span class="keyword">int</span>[][] pairs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [][] a=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> match[]= <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  preferences.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;  preferences[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">a[i][preferences[i][j]]=j;<span class="comment">//预处理，值越小的亲密度越高</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] i : pairs) &#123;<span class="comment">//预处理，匹配，避免后续在pairs中寻找</span></span><br><span class="line">match[i[<span class="number">0</span>]]=i[<span class="number">1</span>];</span><br><span class="line">match[i[<span class="number">1</span>]]=i[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt;n; u++) &#123;</span><br><span class="line"><span class="keyword">if</span>(u==x)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(a[x][u]&lt;a[x][match[x]]&amp;&amp;a[u][x]&lt;a[u][match[u]])</span><br><span class="line">&#123;</span><br><span class="line">c++;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>预处理,匹配</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字1的个数</title>
      <link href="/2021/08/13/leetcode/%E6%95%B0%E5%AD%971%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2021/08/13/leetcode/%E6%95%B0%E5%AD%971%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="233-数字-1-的个数"><a href="#233-数字-1-的个数" class="headerlink" title="233. 数字 1 的个数"></a><a href="https://leetcode-cn.com/problems/number-of-digit-one/">233. 数字 1 的个数</a></h1><p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p><p>示例 1：</p><p>输入：n = 13<br>输出：6<br>示例 2：</p><p>输入：n = 0<br>输出：0</p><p>提示：</p><p>0 &lt;= n &lt;= 2 * 109</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><img src="https://gitee.com/sellun/cnblog/raw/master/leetcodeImg/1.png"></p><p>注意溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> digit=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> k=n;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">long</span> r=k%<span class="number">10</span>;</span><br><span class="line">    k/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;<span class="number">1</span>)</span><br><span class="line">    sum+=n/(digit*<span class="number">10</span>)*digit+digit;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r==<span class="number">1</span>)</span><br><span class="line">    sum+=n/(digit*<span class="number">10</span>)*digit+n%digit+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    sum+=(n/(digit*<span class="number">10</span>)-<span class="number">1</span>)*digit+digit;</span><br><span class="line">    <span class="keyword">if</span>(n/(digit*<span class="number">10</span>)==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    digit*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文串,子序列</title>
      <link href="/2021/08/12/leetcode/%E5%9B%9E%E6%96%87%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2021/08/12/leetcode/%E5%9B%9E%E6%96%87%E4%B8%B2%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></h1><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>示例 1：</p><p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：</p><p>输入：s = “cbbd”<br>输出：”bb”<br>示例 3：</p><p>输入：s = “a”<br>输出：”a”<br>示例 4：</p><p>输入：s = “ac”<br>输出：”a”</p><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s 仅由数字和英文字母（大写和/或小写）组成</p><h2 id="解法1-动态规划"><a href="#解法1-动态规划" class="headerlink" title="解法1.动态规划"></a>解法1.动态规划</h2><p>定义dp[i][j] 为字符串s[i]……s[j]是不是回文串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=s.length();</span><br><span class="line">    <span class="keyword">boolean</span> dp[][] = <span class="keyword">new</span> <span class="keyword">boolean</span> [n][n];</span><br><span class="line">     dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">dp[i][i]=<span class="keyword">true</span>;<span class="comment">//预处理</span></span><br><span class="line">dp[i][i-<span class="number">1</span>]=<span class="keyword">true</span>;<span class="comment">//两个连在一起,相同的情况</span></span><br><span class="line">&#125;</span><br><span class="line">     <span class="keyword">char</span>[] ch=s.toCharArray();<span class="comment">//多交了几发,转化成数组更加省时间</span></span><br><span class="line">    <span class="keyword">int</span> maxi=<span class="number">0</span>,maxlen=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//倒着来,画个图就知道了,得先知道dp[i+1][j-1]才能晓得dp[i][j]</span></span><br><span class="line">        <span class="comment">//递推式子在下面自己看</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(ch[i]==ch[j]&amp;&amp;dp[i+<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j]=<span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;maxlen)</span><br><span class="line">&#123;</span><br><span class="line">maxlen=j-i+<span class="number">1</span>;</span><br><span class="line">maxi=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j]=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(maxi,maxi+maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法2-从中间向两边扩散"><a href="#解法2-从中间向两边扩散" class="headerlink" title="解法2.从中间向两边扩散"></a>解法2.从中间向两边扩散</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">String res;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;find(i,i,s);</span><br><span class="line">        find(i,i+<span class="number">1</span>,s);&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">find</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(m&gt;=<span class="number">0</span>&amp;&amp;n&lt;s.length()&amp;&amp;s.charAt(m)==s.charAt(n))</span><br><span class="line">    &#123;m--;n++;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n-m-<span class="number">1</span>&gt;res.length()&amp;&amp;s.charAt(m+<span class="number">1</span>)==s.charAt(n-<span class="number">1</span>))</span><br><span class="line">    res=s.substring(m+<span class="number">1</span>,n);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode-cn.com/problems/qJnOS7/">最长公共子序列</a></h1><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    text1=<span class="string">&quot; &quot;</span>+text1;</span><br><span class="line">    text2=<span class="string">&quot; &quot;</span>+text2;</span><br><span class="line">    <span class="keyword">int</span> [][] dp= <span class="keyword">new</span> <span class="keyword">int</span>[text1.length()][text2.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(text1.charAt(i)==text2.charAt(j))</span><br><span class="line">dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">dp[i][j]=Math.max(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> dp[text1.length()-<span class="number">1</span>][text2.length()-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence">最长回文子序列</a></h1><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p> </p><p>示例 1：</p><p>输入：s = “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” 。<br>示例 2：</p><p>输入：s = “cbbd”<br>输出：2<br>解释：一个可能的最长回文子序列为 “bb” 。 </p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch[]=s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n=s.length();</span><br><span class="line">    <span class="keyword">int</span> dp[][]= <span class="keyword">new</span> <span class="keyword">int</span> [n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">dp[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; dp.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(ch[i]==ch[j])</span><br><span class="line">dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j]=Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/zi-xu-lie-wen-ti-tong-yong-si-lu-zui-chang-hui-wen/">参考思路,主要是后面那个图很好</a></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等差数列</title>
      <link href="/2021/08/11/leetcode/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/"/>
      <url>/2021/08/11/leetcode/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices">413. 等差数列划分</a></h1><p>如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><p>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。<br>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。</p><p>子数组 是数组中的一个连续序列。</p><p> </p><p>示例 1：</p><p>输入：nums = [1,2,3,4]<br>输出：3<br>解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。<br>示例 2：</p><p>输入：nums = [1]<br>输出：0   </p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p><code>dp[i]代表以i位置为等差数列最后的值的个数</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i - <span class="number">1</span>] -nums[i - <span class="number">2</span>] == nums[i]-nums[i - <span class="number">1</span>])</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">count += dp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="446-等差子序列划分2"><a href="#446-等差子序列划分2" class="headerlink" title="446. 等差子序列划分2"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/">446. 等差子序列划分2</a></h1><p>给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。</p><p>如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。</p><p>例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。<br>再例如，[1, 1, 2, 5, 7] 不是等差序列。<br>数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。</p><p>例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。<br>题目数据保证答案是一个 32-bit 整数。</p><p> </p><p>示例 1：</p><p>输入：nums = [2,4,6,8,10]<br>输出：7<br>解释：所有的等差子序列为：<br>[2,4,6]<br>[4,6,8]<br>[6,8,10]<br>[2,4,6,8]<br>[4,6,8,10]<br>[2,4,6,8,10]<br>[2,6,10]<br>示例 2：</p><p>输入：nums = [7,7,7,7,7]<br>输出：16<br>解释：数组中的任意子序列都是等差子序列。 </p><p>提示：</p><p>1  &lt;= nums.length &lt;= 1000<br>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><code>dp[i] 是一个 hashmap 类型</code><br><code>来记录以dp[i]为结尾的,差值为d的个数</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Long, Integer&gt; dp[]= <span class="keyword">new</span> HashMap[nums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">dp[i]=<span class="keyword">new</span> HashMap&lt;Long, Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">long</span>  d=<span class="number">1l</span>*nums[i]-nums[j];<span class="comment">//细节,long,之前写的int类型,找半天都没找到错误,也得注意数据类型</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> k=dp[j].getOrDefault(d, <span class="number">0</span>);</span><br><span class="line">dp[i].put(d,dp[i].getOrDefault(d, <span class="number">0</span>)+k+<span class="number">1</span>);<span class="comment">//又是一个细节,得加上dp[i].get...原来的值</span></span><br><span class="line">c+=k;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡字符串</title>
      <link href="/2021/08/10/leetcode/%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/08/10/leetcode/%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/">1963. 使字符串平衡的最小交换次数</a><br>给你一个字符串 s ，下标从 0 开始 ，且长度为偶数 n 。字符串 恰好 由 n / 2 个开括号 ‘[‘ 和 n / 2 个闭括号 ‘]’ 组成。</p><p>只有能满足下述所有条件的字符串才能称为 平衡字符串 ：</p><p>字符串是一个空字符串，或者<br>字符串可以记作 AB ，其中 A 和 B 都是 平衡字符串 ，或者<br>字符串可以写成 [C] ，其中 C 是一个 平衡字符串 。<br>你可以交换 任意 两个下标所对应的括号 任意 次数。</p><p>返回使 s 变成 平衡字符串 所需要的 最小 交换次数。</p><p> </p><p>示例 1：</p><p>输入：s = “][][“<br>输出：1<br>解释：交换下标 0 和下标 3 对应的括号，可以使字符串变成平衡字符串。<br>最终字符串变成 “[[]]” 。  </p><p>示例 2：</p><p>输入：s = “]]][[[“<br>输出：2<br>解释：执行下述操作可以使字符串变成平衡字符串：  </p><ul><li>交换下标 0 和下标 4 对应的括号，s = “[]][[]” 。</li><li>交换下标 1 和下标 5 对应的括号，s = “[[][]]” 。<br>最终字符串变成 “[[][]]” 。</li></ul><p>示例 3：</p><p>输入：s = “[]”<br>输出：0<br>解释：这个字符串已经是平衡字符串。   </p><p>提示：</p><p>n == s.length<br>2 &lt;= n &lt;= 106<br>n 为偶数<br>s[i] 为’[‘ 或 ‘]’<br>开括号 ‘[‘ 的数目为 n / 2 ，闭括号 ‘]’ 的数目也是 n / 2  </p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于一个平衡字符串，从左往右遍历它，统计未匹配的左括号的个数 cc，遇到左括号就加一，遇到右括号就减一，如果任何时刻 cc 都不为负数，那么这个字符串就是平衡的。</p><p>如果遍历时遇到右括号并且此时 c=0c=0，那么就需要在后面找一个左括号并与这个右括号交换。</p><p>为了使后续的交换次数最小，这个被交换走的右括号应当越靠右越好，所以我们可以拿字符串最右边的左括号来交换。</p><p>实际代码中，可以不用编写「交换」的逻辑，这是因为我们总是选择最右边的左括号，因此在后续的遍历中，若遇到了这些左括号，在交换后的字符串上，该位置及后面必然全部是右括号，即此时该字符串已经是平衡的了。</p><p>因此，当遇到右括号并且此时 c=0c=0，可以直接将 cc 和答案加一，即视作将一个左括号和该右括号交换。由于没有实际交换括号，若后面又重新遇到了需要被交换的左括号，由于此时字符串已经是平衡的了，故不会对答案产生影响。</p><p>作者：<a href="https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/solution/go-tan-xin-by-endlesscheng-7h9n/">endlesschen</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span> k=s.charAt(i);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c&gt;<span class="number">0</span>)</span><br><span class="line">c--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">c++;</span><br><span class="line">res++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>作者这思路也太棒了吧！！！<br>类似题目还有 去掉平衡字符串最外层括号<br>求平衡字符串得分</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丑数</title>
      <link href="/2021/08/09/leetcode/%E4%B8%91%E6%95%B0/"/>
      <url>/2021/08/09/leetcode/%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/ugly-number/">263. 丑数</a>    </p><p>给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。<br>丑数 就是只包含质因数 2、3 和/或 5 的正整数。1 通常被视为丑数。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据丑数的定义，00 和负整数一定不是丑数。</p><p>当 n&gt;0n&gt;0 时，若 nn 是丑数，则 nn 可以写成 n = 2^a \times 3^b \times 5^cn=2<br>a<br> ×3<br>b<br> ×5<br>c<br>  的形式，其中 a,b,ca,b,c 都是非负整数。特别地，当 a,b,ca,b,c 都是 00 时，n=1n=1。</p><p>为判断 nn 是否满足上述形式，可以对 nn 反复除以 2,3,52,3,5，直到 nn 不再包含质因数 2,3,52,3,5。若剩下的数等于 11，则说明 nn 不包含其他质因数，是丑数；否则，说明 nn 包含其他质因数，不是丑数。</p><p>作者：<a href="https://leetcode-cn.com/problems/ugly-number/solution/chou-shu-by-leetcode-solution-fazd/">LeetCode-Solution</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">    n=n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(n%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">    n=n/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(n%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">    n=n/<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> n==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="丑数2"><a href="#丑数2" class="headerlink" title="丑数2"></a>丑数2</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a><br>给你一个整数 n ，请你找出并返回第 n 个 丑数 。</p><p>丑数 就是只包含质因数 2、3 和/或 5 的正整数。</p><h2 id="解法一-最小堆和set去重"><a href="#解法一-最小堆和set去重" class="headerlink" title="解法一   最小堆和set去重"></a>解法一   最小堆和set去重</h2><p>要得到从小到大的第 nn 个丑数，可以使用最小堆实现。</p><p>初始时堆为空。首先将最小的丑数 11 加入堆。</p><p>每次取出堆顶元素 xx，则 xx 是堆中最小的丑数，由于 2x, 3x, 5x2x,3x,5x 也是丑数，因此将 2x, 3x, 5x2x,3x,5x 加入堆。</p><p>上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。</p><p>在排除重复元素的情况下，第 nn 次从最小堆中取出的元素即为第 nn 个丑数。</p><p><a href="https://leetcode-cn.com/problems/ugly-number-ii/solution/chou-shu-ii-by-leetcode-solution-uoqd/">LeetCode-Solution</a></p><p>使用最小堆，会预先存储较多的丑数，导致空间复杂度较高，维护最小堆的过程也导致时间复杂度较高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Long&gt; visited= <span class="keyword">new</span> HashSet&lt;Long&gt;();</span><br><span class="line">    PriorityQueue&lt;Long&gt; q=<span class="keyword">new</span> PriorityQueue&lt;Long&gt;();</span><br><span class="line">    q.add(<span class="number">1l</span>);</span><br><span class="line">    <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    res=q.poll();</span><br><span class="line">    <span class="keyword">long</span> a=res*<span class="number">2</span>,b=res*<span class="number">3</span>,c=res*<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(!visited.contains(a))</span><br><span class="line">    &#123;</span><br><span class="line">    q.add(a);</span><br><span class="line">    visited.add(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!visited.contains(b))</span><br><span class="line">    &#123;</span><br><span class="line">    q.add(b);</span><br><span class="line">    visited.add(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!visited.contains(c))</span><br><span class="line">    &#123;</span><br><span class="line">    q.add(c);</span><br><span class="line">    visited.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二-动态规划-三指针"><a href="#解法二-动态规划-三指针" class="headerlink" title="解法二  动态规划,三指针"></a>解法二  动态规划,三指针</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num2 = dp[p2] * <span class="number">2</span>, num3 = dp[p3] * <span class="number">3</span>, num5 = dp[p5] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(Math.min(num2, num3), num5);</span><br><span class="line">            <span class="comment">//三个if的避免了重复的情况，算过了，指针加加，就不用再算了</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num2) &#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num3) &#123;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num5) &#123;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="超级丑数"><a href="#超级丑数" class="headerlink" title="超级丑数"></a>超级丑数</h1><p><a href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></p><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。</p><p>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。</p><p>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。</p><p> </p><p>示例 1：</p><p>输入：n = 12, primes = [2,7,13,19]<br>输出：32<br>解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>解法与丑数2一致，两种方法都行。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2021/08/09/little_thing/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2021/08/09/little_thing/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p><code>int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2</code></p><p><code>第一个，最基本的二分查找算法：</code></p><p>因为我们初始化 right = nums.length - 1<br>所以决定了我们的「搜索区间」是 [left, right]<br>所以决定了 while (left &lt;= right)<br>同时也决定了 left = mid+1 和 right = mid-1</p><p>因为我们只需找到一个 target 的索引即可<br>所以当 nums[mid] == target 时可以立即返回</p><p><code>第二个，寻找左侧边界的二分查找：</code></p><p>因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 while (left &lt; right)<br>同时也决定了 left = mid+1 和 right = mid</p><p>因为我们需找到 target 的最左侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧右侧边界以锁定左侧边界</p><p><code>第三个，寻找右侧边界的二分查找：</code></p><p>因为我们初始化 right = nums.length<br>所以决定了我们的「搜索区间」是 [left, right)<br>所以决定了 while (left &lt; right)<br>同时也决定了 left = mid+1 和 right = mid</p><p>因为我们需找到 target 的最右侧索引<br>所以当 nums[mid] == target 时不要立即返回<br>而要收紧左侧边界以锁定右侧边界</p><p>又因为收紧左侧边界时必须 left = mid + 1<br>所以最后无论返回 left 还是 right，必须减一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">int</span> res[] = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length;</span><br><span class="line">        </span><br><span class="line">res[<span class="number">0</span>] = findLeftBound(l, r, nums, target);</span><br><span class="line">res[<span class="number">1</span>] = findRightBound(l, r, nums, target);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findRightBound</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r = mid;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l  == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> nums[l - <span class="number">1</span>] == target ? l-<span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLeftBound</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">r = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// target 比所有数都大</span></span><br><span class="line"><span class="keyword">if</span> (l  == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 类似之前算法的处理方式</span></span><br><span class="line"><span class="keyword">return</span> nums[l ] == target ? l  : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/fCf5QbPDtE6SSlZ1yh_q8Q">边界问题</a><br><a href="https://www.cnblogs.com/kyoner/p/11080078.html">左右边界及边界详解</a><br><a href="https://blog.csdn.net/qq_29611345/article/details/103080287">大于等于</a></p><p>某人说记模板会吃亏的,嗯,吃过亏了,所以花了一个下午来补二分</p>]]></content>
      
      
      <categories>
          
          <category> little_thing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长递增子序列</title>
      <link href="/2021/08/08/leetcode/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2021/08/08/leetcode/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/find-the-longest-valid-obstacle-course-at-each-position/">5841. 找出到每个位置为止最长的有效障碍赛跑路线</a><br><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="300-1"><a href="#300-1" class="headerlink" title="300_1"></a>300_1</h2><p>O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[]= <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i]&gt;nums[j])</span><br><span class="line">max=Math.max(max, dp[j]);</span><br><span class="line">&#125;</span><br><span class="line">dp[i]=max+<span class="number">1</span>;</span><br><span class="line">res=Math.max(res, max);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="300-2"><a href="#300-2" class="headerlink" title="300_2"></a>300_2</h2><p>O(nlogn)<br>很具小巧思。新建数组 cell，用于保存最长上升子序列。</p><p>对原序列进行遍历，将每位元素二分插入 cell 中。</p><ul><li>如果 cell 中元素都比它小，将它插到最后</li><li>否则，用它覆盖掉比它大的元素中最小的那个。</li></ul><p>总之，思想就是让 cell 中存储比较小的元素。这样，cell 未必是真实的最长上升子序列，但长度是对的。</p><p>作者：coldme-2<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st[]= <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</span><br><span class="line">    st[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; st.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i]&gt;st[j])</span><br><span class="line">st[++j]=nums[i];</span><br><span class="line"><span class="comment">//否则找到里面最小的比他大的元素用nums[i]替换掉</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=j,mid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r) &#123;<span class="comment">//如果遇到相等的，应该替换掉最左边的那个元素</span></span><br><span class="line">mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(st[mid]&gt;=nums[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(mid!=<span class="number">0</span>&amp;&amp;nums[i]&gt;st[mid-<span class="number">1</span>]||mid ==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">r=mid-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l=mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">st[mid]=nums[i];</span><br><span class="line">&#125;##</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是的，二分基础不打好会吃亏的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5841"><a href="#5841" class="headerlink" title="5841"></a>5841</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] longestObstacleCourseAtEachPosition(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> st[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"><span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">st[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; st.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt;= st[j]) &#123;</span><br><span class="line">st[++j] = nums[i];</span><br><span class="line">res[i] = j+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则找到里面最小的比他大的元素用nums[i]替换掉</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = j, mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (st[mid] &gt; nums[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(mid!=<span class="number">0</span>&amp;&amp;st[mid-<span class="number">1</span>]&lt;=nums[i])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">st[mid] = nums[i];</span><br><span class="line">res[i] = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>遇到这类型的题好多次了,有两次都是因为自己只会解法1而超时,以前也想搞懂第二种,但是都半途而废了,今天痛定思痛,花了较长时间来理解,看了很多题解,尤其推荐这三篇   </p><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/">题解一</a>这个动画超级好理解<br><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/yi-ti-shuang-jie-tu-jie-yuan-li-ji-chu-d-ptpz/">题解二</a>图画得很详细,让我写5841的时候都不要看题解了<br><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/">题解三</a>语言精炼且好懂   </p><p>还有…我要去补二分了orz</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XTU 1040. 零件</title>
      <link href="/2021/08/07/xtuoj/1040/"/>
      <url>/2021/08/07/xtuoj/1040/</url>
      
        <content type="html"><![CDATA[<h1 id="零件"><a href="#零件" class="headerlink" title="零件"></a>零件</h1><p><a href="http://202.197.224.59/exam/index.php/problem/read/id/1040">零件</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>求出最长的一行<br>然后长乘宽减去x的个数   </p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>超内存了提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> K=in.nextInt();</span><br><span class="line"><span class="keyword">while</span>(K--&gt;<span class="number">0</span>)</span><br><span class="line">&#123;<span class="keyword">int</span> sumX=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n= in.nextInt();</span><br><span class="line">String s1[]= <span class="keyword">new</span> String[n];</span><br><span class="line">String s2[]= <span class="keyword">new</span> String[n];</span><br><span class="line"><span class="keyword">int</span> left[]= <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line"><span class="keyword">int</span> right[]= <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length; i++) &#123;</span><br><span class="line">s1[i]=in.next();</span><br><span class="line">left[i]=s1[i].length();</span><br><span class="line">sumX+=findX(s1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length; i++) &#123;</span><br><span class="line">s2[i]=in.next();</span><br><span class="line">right[i]=s2[i].indexOf(<span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">sumX+=findX(s2[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max=-<span class="number">1</span>,maxindex=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(left[i]-right[i]&gt;max) &#123;</span><br><span class="line">max=left[i]-right[i];</span><br><span class="line">maxindex=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len=left[maxindex]+s2[maxindex].length()-right[maxindex];</span><br><span class="line"><span class="keyword">int</span> sum=len*n;</span><br><span class="line">System.out.println(sum-sumX);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findX</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span> ch=string.charAt(i);</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">c++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="c"><a href="#c" class="headerlink" title="c"></a>c</h2><p>一样的解法 ac</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_x</span><span class="params">(<span class="keyword">char</span> s[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_first_x</span><span class="params">(<span class="keyword">char</span>  s[] )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> K;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;K);</span><br><span class="line">    <span class="keyword">while</span>(K--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sumX=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">char</span> ch=getchar();</span><br><span class="line">        <span class="keyword">char</span> s1[n][<span class="number">30</span>],s2[n][<span class="number">30</span>];</span><br><span class="line">        <span class="keyword">int</span> left[n],right[n];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            gets(s1[i]);</span><br><span class="line">            left[i]=<span class="built_in">strlen</span>(s1[i]);</span><br><span class="line">            sumX+=find_x(s1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            gets(s2[i]);</span><br><span class="line">            right[i]=get_first_x(s2[i]);</span><br><span class="line">            sumX+=find_x(s2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">-1</span>,maxindex=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left[i]-right[i]&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                max=left[i]-right[i];</span><br><span class="line">                maxindex=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=left[maxindex]+<span class="built_in">strlen</span>(s2[<span class="number">0</span>])-right[maxindex];</span><br><span class="line">        <span class="keyword">int</span> sum=len*n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum-sumX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_x</span><span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>,i;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">            c++;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_first_x</span><span class="params">(<span class="keyword">char</span> s[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>,i;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> xtuoj </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xtuoj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1856. 子数组最小乘积的最大值</title>
      <link href="/2021/08/05/leetcode/1856/"/>
      <url>/2021/08/05/leetcode/1856/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ol start="1856"><li>子数组最小乘积的最大值</li></ol><p>一个数组的 最小乘积 定义为这个数组中 最小值 乘以 数组的 和 。</p><pre><code>比方说，数组 [3,2,5] （最小值是 2）的最小乘积为 2 * (3+2+5) = 2 * 10 = 20 。</code></pre><p>给你一个正整数数组 nums ，请你返回 nums 任意 非空子数组 的最小乘积 的 最大值 。由于答案可能很大，请你返回答案对  109 + 7 取余 的结果。</p><p>请注意，最小乘积的最大值考虑的是取余操作 之前 的结果。题目保证最小乘积的最大值在 不取余 的情况下可以用 64 位有符号整数 保存。</p><p>子数组 定义为一个数组的 连续 部分。</p><p>示例 1：</p><p>输入：nums = [1,2,3,2]<br>输出：14<br>解释：最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。<br>2 * (2+3+2) = 2 * 7 = 14 。</p><p>示例 2：</p><p>输入：nums = [2,3,3,1,2]<br>输出：18<br>解释：最小乘积的最大值由子数组 [3,3] （最小值是 3）得到。<br>3 * (3+3) = 3 * 6 = 18 。</p><p>示例 3：</p><p>输入：nums = [3,1,5,6,4,2]<br>输出：60<br>解释：最小乘积的最大值由子数组 [5,6,4] （最小值是 4）得到。<br>4 * (5+6+4) = 4 * 15 = 60 。</p><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 1051 &lt;= nums[i] &lt;= 107</code></pre><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p> 提示 1</p><p>「最小乘积」的定义为「最小值」乘以「和」，由于「和」较难进行枚举，我们可以考虑枚举「最小值」。</p><p>提示 2</p><p>我们可以枚举数组中的每个元素作为最小值。</p><p>由于数组中的元素均为正数，那么我们选择的包含最小值的子数组是越长越好的。</p><p>即找到每个最小值的左右两边的更小值即可找到区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumMinProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Deque&lt;Integer&gt; st = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; nums[st.peekLast()] &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = st.pollLast();</span><br><span class="line">                right[t] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            st.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!st.isEmpty())</span><br><span class="line">            right[st.pollLast()] = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; nums[st.peekLast()] &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = st.pollLast();</span><br><span class="line">                left[t] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            st.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!st.isEmpty())</span><br><span class="line">            left[st.pollLast()] = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//      long max=0;</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; left.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//             int s=0;</span></span><br><span class="line"><span class="comment">//             for (int j = left[i]+1; j &lt;= right[i]-1; j++) &#123;</span></span><br><span class="line"><span class="comment">//                 s+=nums[j];</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             max=Math.max(nums[i]*s, max);</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return (int)(max%(1000000007));</span></span><br><span class="line">     </span><br><span class="line">        <span class="keyword">long</span> sum[] = <span class="keyword">new</span> <span class="keyword">long</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            sum[i+<span class="number">1</span>]=sum[i]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> l=nums[i]*(sum[right[i]]-sum[left[i]+<span class="number">1</span>]);</span><br><span class="line">            max=Math.max(max, l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(max%<span class="number">1000000007</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>不知道为什么注释的地方错了</p><p>但是前缀和显然更省时间,多次求区间和的可以考虑使用前缀和.</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>316. 去除重复字母</title>
      <link href="/2021/08/04/leetcode/316/"/>
      <url>/2021/08/04/leetcode/316/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. 去除重复字母</a></p><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><p>示例 1：</p><p>输入：s = “bcabc”<br>输出：”abc”</p><p>示例 2：</p><p>输入：s = “cbacdcbc”<br>输出：”acdb”</p><p>提示：</p><pre><code>1 &lt;= s.length &lt;= 104s 由小写英文字母组成</code></pre><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] lastIndex=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">150</span>];</span><br><span class="line">        <span class="keyword">char</span> ch[]=s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">            lastIndex[ch[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> visited[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">150</span>];</span><br><span class="line">        Deque&lt;Character&gt; st=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[ch[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!st.isEmpty()&amp;&amp; st.peekLast()&gt;=ch[i]&amp;&amp;i&lt;=lastIndex[st.peekLast()])</span><br><span class="line">                &#123;</span><br><span class="line">                   visited[st.pollLast()]=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                st.addLast(ch[i]);</span><br><span class="line">                visited[ch[i]]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!st.isEmpty())</span><br><span class="line">        res+=st.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><ul><li>栈里面在不破坏每一个字母都出现的情况下尽量保持单调递增以维护字典序最小</li><li>要保持没一个字母是否出现则要记录每一个字母最后出现的位置或次数</li><li>得记录栈里面是否出现过该字母</li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>581. 最短无序连续子数组</title>
      <link href="/2021/08/04/leetcode/581/"/>
      <url>/2021/08/04/leetcode/581/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></p><p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 最短 子数组，并输出它的长度。</p><p>示例 1：</p><p>输入：nums = [2,6,4,8,10,9,15]<br>输出：5<br>解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</p><p>示例 2：</p><p>输入：nums = [1,2,3,4]<br>输出：0</p><p>示例 3：</p><p>输入：nums = [1]<br>输出：0</p><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 104-105 &lt;= nums[i] &lt;= 105</code></pre><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><pre><code>    题目目标是求得可以满足排序一个子数组, 使得全数组为升序的最短子数组的长度;    解析题目要求, 我们可以知道, 要求的子数组需要满足的特征值:    子数组左边的所有元素, 值都要比子数组的最小元素要小;    子数组右边的所有元素, 值都要比子数组的最大元素要大;    根据步骤2中的分析, 我们可以把问题转化为一下模型: 分别求左右两个边界点, 使得右边界点右侧的所有元素值, 比边界内的最大值要大; 左边界点左侧的所有元素, 比边界内的最小值要小;    因此可以套用双指针的模型:    从左到右遍历, 只要碰到比已经遍历过路径内的最大值要小的元素, 则说明该元素需要被纳入到重排序的子数组中;    同理, 再从右往左遍历, 只要碰到比已经遍历过的路径内的最小值还要大的元素, 说明该元素也需要被纳入到重排序的子数组中;    此方法的时间复杂度为O(2n)</code></pre><p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/java-shuang-zhi-zhen-shuang-xiang-bian-l-etqf/">思路参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> r=<span class="number">0</span>,l=<span class="number">0</span>,j;</span><br><span class="line">      <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> min= nums.length-<span class="number">1</span>;;</span><br><span class="line">      <span class="keyword">for</span> (  j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(nums[j]&gt;=nums[max])</span><br><span class="line">          max=j;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          r=j;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (  j = nums.length-<span class="number">1</span>; j &gt;=<span class="number">0</span> ; j--) &#123;</span><br><span class="line">          <span class="keyword">if</span>(nums[j]&lt;=nums[min])</span><br><span class="line">          min=j;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          l=j;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> r==l?<span class="number">0</span>:r-l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>直接排序,找不同即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] clone=nums.clone();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.length&amp;&amp;clone[i]==nums[i])i++;</span><br><span class="line">        l=i;i=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==nums.length)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;clone[i]==nums[i])i--;</span><br><span class="line">        r=i;</span><br><span class="line">        <span class="keyword">return</span> r-l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91. 股票价格跨度</title>
      <link href="/2021/08/04/leetcode/91/"/>
      <url>/2021/08/04/leetcode/91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。</p><p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><p>例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/online-stock-span">https://leetcode-cn.com/problems/online-stock-span</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; st,weight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StockSpanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        weight=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!st.isEmpty()&amp;&amp;st.peekLast()&lt;=price)</span><br><span class="line">        &#123;</span><br><span class="line">            w+=weight.pollLast();</span><br><span class="line">            st.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        st.addLast(price);</span><br><span class="line">        weight.addLast(w);</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><ul><li>注意weight记录值</li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>84. 柱状图中最大的矩形</title>
      <link href="/2021/08/03/leetcode/84/"/>
      <url>/2021/08/03/leetcode/84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"><br>示例 1:</p><p>输入：heights = [2,1,5,6,2,3]<br>输出：10<br>解释：最大的矩形为图中红色区域，面积为 10</p><p>提示：</p><pre><code>1 &lt;= heights.length &lt;=1050 &lt;= heights[i] &lt;= 104</code></pre><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>单调栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; st = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.isEmpty()&amp;&amp;height[st.peekLast()]&gt;height[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> curHeight=height[st.pollLast()];</span><br><span class="line">                <span class="keyword">int</span> width=st.isEmpty()?i:i-st.peekLast()-<span class="number">1</span>;</span><br><span class="line">                max=Math.max(max, width*curHeight);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(st.isEmpty()||height[i]&gt;=height[st.peekLast()])</span><br><span class="line">            st.addLast(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curHeight=height[st.pollLast()];</span><br><span class="line">                <span class="keyword">int</span> width=st.isEmpty()?i:i-st.peekLast()-<span class="number">1</span>;</span><br><span class="line">                max=Math.max(max, width*curHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>这个题终于自己写出来了<br>注意的几点</p><ul><li>维护一个单调递增的栈,渐渐寻找一右边为高度的矩形面积,宽度只要往左看,因为他是单调递增的</li><li>注意栈里面的最后一个元素可以延伸到最前面和最后面,不仅仅是最后的处理,还有入栈弹栈的过程也是</li><li>宽度是当前下标与新栈顶元素的差值再减一！！！ 就是这里，错了好久还不自知，把爷给整自闭了</li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 17.21. 直方图的水量</title>
      <link href="/2021/08/02/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.21.%20%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/"/>
      <url>/2021/08/02/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.21.%20%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci">面试题 17.21. 直方图的水量</a><br>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png"></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 感谢 Marcos 贡献此图。</p><p>示例:</p><p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>一层一层算全部的和,总体积减去柱子体积就是水的容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : height) &#123;</span><br><span class="line">            max=Math.max(max, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;height[l]&lt;i)l++;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;height[r]&lt;i)r--;</span><br><span class="line">            sum+=r-l+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hSun=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : height) &#123;</span><br><span class="line">            hSun+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum-hSun;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>从两端遍历求最高的柱子,记录下来,减少遍历次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.length &lt;= <span class="number">0</span>)<span class="comment">//注意这里</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] record = <span class="keyword">new</span> <span class="keyword">int</span>[height.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> lmax = height[<span class="number">0</span>], rmax = height[height.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        record[l][<span class="number">0</span>] = lmax;</span><br><span class="line">        record[r][<span class="number">1</span>] = rmax;</span><br><span class="line">           <span class="comment">//预处理得到每个位置的左边和右边的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (l=l+<span class="number">1</span>,r=r-<span class="number">1</span>; l &lt; height.length;l++,r--) &#123;</span><br><span class="line">            record[l][<span class="number">0</span>] = lmax;</span><br><span class="line">            record[r][<span class="number">1</span>] = rmax;</span><br><span class="line">            <span class="keyword">if</span> (height[l] &gt; lmax)</span><br><span class="line">                lmax = height[l];</span><br><span class="line">            <span class="keyword">if</span> (height[r] &gt; rmax)</span><br><span class="line">                rmax = height[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = Math.min(record[i][<span class="number">0</span>], record[i][<span class="number">1</span>]) - height[i];</span><br><span class="line">            sum += k &lt;= <span class="number">0</span> ? <span class="number">0</span> : k;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>单调栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = stack.peek();</span><br><span class="line">                <span class="keyword">int</span> currWidth = i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> currHeight = Math.min(height[left], height[i]) - height[top];</span><br><span class="line">                ans += currWidth * currHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h2><p>动态规划</p><h2 id="解法五"><a href="#解法五" class="headerlink" title="解法五"></a>解法五</h2><p>双指针,两边从低处开始蓄水</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/solution/shuang-zhi-zhen-an-xing-qiu-jie-xiang-xi-d162/">解法一</a><br><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/solution/gong-shui-san-xie-yi-ti-si-jie-po-su-yu-sqadp/">解法二</a><br><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/solution/zhi-fang-tu-de-shui-liang-by-leetcode-so-7rla/">解法三解法四</a></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程</title>
      <link href="/2021/08/01/java/java_thread/"/>
      <url>/2021/08/01/java/java_thread/</url>
      
        <content type="html"><![CDATA[<h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><ol><li>继承Thread类</li><li>重写run方法</li><li>调用start开启线程</li></ol><p>main里面调用run方法,就是和普通调用方法一样,只有一个主线程,调用start(),开启线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">         <span class="keyword">long</span> minPrime;</span><br><span class="line">         PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">             <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">              . . .</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>主线程调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">    p.start();</span><br></pre></td></tr></table></figure><h1 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h1><p>更推荐使用,避免了单线程的局限性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> minPrime;</span><br><span class="line">        PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">            <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">             . . .</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 主线程调用<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure></p><h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><p><a href="https://www.cnblogs.com/guanbin-529/p/11784914.html">callable及futrue详解</a></p><h1 id="lamda-表达式"><a href="#lamda-表达式" class="headerlink" title="lamda 表达式"></a>lamda 表达式</h1><p><code>函数式接口</code> 只包含唯一一个抽象的接口<br>对于函数式接口,可以通过lamda表达式来创建该接口的对象<br>局部内部类 :在main函数里面的类<br>匿名内部类 : 没有类的名称,必须借助接口或者父类,在main里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">like= <span class="keyword">new</span> interfaceLike()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lamda</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kkk=()-&gt;&#123;...&#125;；</span><br></pre></td></tr></table></figure><h1 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h1><p>使用标志位来进行终止变量   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;<span class="comment">//标志位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">       </span><br><span class="line">       Main mm=<span class="keyword">new</span> Main();</span><br><span class="line">       Thread thread=<span class="keyword">new</span> Thread(mm);</span><br><span class="line">       thread.start();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">          &#123;</span><br><span class="line">           mm.stop1();<span class="comment">//这里注意一下</span></span><br><span class="line">           System.out.println(<span class="string">&quot;mm is stop&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;main &quot;</span>+i);</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="线程休眠sleep"><a href="#线程休眠sleep" class="headerlink" title="线程休眠sleep"></a>线程休眠sleep</h1><p><code>Thread.sleep()</code><br>使当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，取决于系统计时器和调度程序的精度和准确性。该线程不会失去任何监视器的所有权。</p><h1 id="线程礼让yield"><a href="#线程礼让yield" class="headerlink" title="线程礼让yield"></a>线程礼让yield</h1><p>向调度程序提示当前线程愿意放弃其当前对处理器的使用。调度程序可以随意忽略此提示。<br>Yield 是一种启发式尝试，旨在改善线程之间的相对进展，否则会过度使用 CPU。它的使用应与详细的分析和基准测试相结合，以确保它确实具有预期的效果。</p><p>很少适合使用这种方法。它对于调试或测试目的可能很有用，它可能有助于重现由于竞争条件引起的错误。在设计并发控制结构（例如java.util.concurrent.locks包中的结构）时，它也可能很有用 。</p><p>以上摘自官方文档,说人话就是,当前正在执行的线程从运行态转为就绪态,然后cpu重新调度</p><h1 id="线程加入"><a href="#线程加入" class="headerlink" title="线程加入"></a>线程加入</h1><p>等待这个线程死亡。<br><a href="https://www.jianshu.com/p/fc51be7e5bc0">线程的作用和原理</a></p><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>Thread.State   –getState()</p><pre><code>- BLOCKED         线程阻塞等待监视器锁的线程状态。- NEW             尚未启动的线程的线程状态。- RUNNABLE        可运行线程的线程状态。- TERMINATED      终止线程的线程状态。- TIMED_WAITING   具有指定等待时间的等待线程的线程状态。- WAITING         等待线程的线程状态。</code></pre><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p><code>public final void setDaemon​(boolean on)</code><br> 将此线程标记为守护线程或用户线程。当唯一运行的线程都是守护线程时，Java 虚拟机退出。<br>必须在线程启动之前调用此方法。</p><p>参数：<br>on- if true，将此线程标记为守护线程   </p><p>在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。 </p><p>所谓守护 线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。</p><p>用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。</p><p>将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。在使用守护线程时需要注意一下几点：</p><p>(1) thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 </p><p>(2) 在Daemon线程中产生的新线程也是Daemon的。</p><p>(3) 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</p><h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><p><code>public void setPriority(int newPriority)</code><br>更改此线程的优先级。<br>首先checkAccess不带参数调用该线程的方法。这可能会导致抛出SecurityException.</p><p>否则，该线程的优先级被设置为newPriority线程的线程组的指定优先级和最大允许优先级中的较小者</p><p>优先级更大有更大的概率先被调度,并不是绝对的</p><p>先设置优先级在启动</p><h1 id="sychronized"><a href="#sychronized" class="headerlink" title="sychronized"></a>sychronized</h1><p><a href="https://www.cnblogs.com/weibanggang/p/9470718.html">sychronized的简介</a><br>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p><ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li><li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li><li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li></ol><ol><li>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞</li><li>synchronized只锁定对象，每个对象只有一个锁（lock）与之相关联</li></ol><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p><a href="https://www.cnblogs.com/dolphin0520/p/3923167.html">Lock相关知识</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java常用实例</title>
      <link href="/2021/07/31/java/java_ofen_using_example/"/>
      <url>/2021/07/31/java/java_ofen_using_example/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.runoob.com/java/java-examples.html">参考资料</a></p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String string=<span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">String reverse = <span class="keyword">new</span> StringBuffer(string).reverse().toString();</span><br></pre></td></tr></table></figure><h2 id="字符串搜索"><a href="#字符串搜索" class="headerlink" title="字符串搜索"></a>字符串搜索</h2><p>String 类的 indexOf() 方法在字符串中查找子字符串出现的位置，如果存在返回字符串出现的位置（第一位为0），如果不存在返回 -1：</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组二分查找"><a href="#数组二分查找" class="headerlink" title="数组二分查找"></a>数组二分查找</h2><p>  int index = Arrays.binarySearch(array, 2);</p><h2 id="数组添加元素"><a href="#数组添加元素" class="headerlink" title="数组添加元素"></a>数组添加元素</h2><p> array = insertElement(array, 1, newIndex);</p><h2 id="数组获取最大和最小值"><a href="#数组获取最大和最小值" class="headerlink" title="数组获取最大和最小值"></a>数组获取最大和最小值</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] numbers = &#123; <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> min = (<span class="keyword">int</span>) Collections.min(Arrays.asList(numbers));</span><br><span class="line">        <span class="keyword">int</span> max = (<span class="keyword">int</span>) Collections.max(Arrays.asList(numbers));</span><br><span class="line">        System.out.println(<span class="string">&quot;最小值: &quot;</span> + min);</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值: &quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a[] = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;I&quot;</span> &#125;;</span><br><span class="line">String b[] = &#123; <span class="string">&quot;O&quot;</span>, <span class="string">&quot;U&quot;</span> &#125;;</span><br><span class="line">List list = <span class="keyword">new</span> ArrayList(Arrays.asList(a));</span><br><span class="line">list.addAll(Arrays.asList(b));</span><br><span class="line">Object[] c = list.toArray();</span><br><span class="line">System.out.println(Arrays.toString(c));      </span><br></pre></td></tr></table></figure><h2 id="找数组中的重复元素"><a href="#找数组中的重复元素" class="headerlink" title="找数组中的重复元素"></a>找数组中的重复元素</h2><p>建议直接set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findDupicateInArray</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.length;j++) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k =j+<span class="number">1</span>;k&lt;a.length;k++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(a[j]==a[k]) &#123;</span><br><span class="line">                   count++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(count==<span class="number">1</span>)</span><br><span class="line">              System.out.println( <span class="string">&quot;重复元素 : &quot;</span> +  a[j] );</span><br><span class="line">           count = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="标签-Label"><a href="#标签-Label" class="headerlink" title="标签(Label)"></a>标签(Label)</h2><p>Java 中的标签是为循环设计的，是为了在多重循环中方便的使用 break 和coutinue 。</p><h2 id="Varargs-可变参数使用"><a href="#Varargs-可变参数使用" class="headerlink" title="Varargs 可变参数使用"></a>Varargs 可变参数使用</h2><p>“Varargs”是”variable number of arguments”的意思。有时候也被简单的称为”variable arguments”</p><p>定义实参个数可变的方法：只要在一个形参的”类型”与”参数名”之间加上三个连续的”.”（即”…”，英文里的句中省略号），就可以让它和不确定个实参相匹配。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">sumvarargs</span><span class="params">(<span class="keyword">int</span>... intArrays)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum, i;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; intArrays.length; i++) &#123;</span><br><span class="line">            sum += intArrays[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        sum = sumvarargs(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">33</span>&#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;数字相加之和为: &quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1850. 邻位交换的最小次数</title>
      <link href="/2021/07/30/leetcode/1850/"/>
      <url>/2021/07/30/leetcode/1850/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number">邻位交换的最小次数</a><br>    给你一个表示大整数的字符串 num ，和一个整数 k 。</p><p>如果某个整数是 num 中各位数字的一个 排列 且它的 值大于 num ，则称这个整数为 妙数 。可能存在很多妙数，但是只需要关注 值最小 的那些。</p><pre><code>例如，num = &quot;5489355142&quot; ：    第 1 个最小妙数是 &quot;5489355214&quot;    第 2 个最小妙数是 &quot;5489355241&quot;    第 3 个最小妙数是 &quot;5489355412&quot;    第 4 个最小妙数是 &quot;5489355421&quot;</code></pre><p>返回要得到第 k 个 最小妙数 需要对 num 执行的 相邻位数字交换的最小次数 。</p><p>测试用例是按存在第 k 个最小妙数而生成的。</p><p>示例 1：</p><p>输入：num = “5489355142”, k = 4<br>输出：2<br>解释：第 4 个最小妙数是 “5489355421” ，要想得到这个数字：</p><ul><li>交换下标 7 和下标 8 对应的位：”5489355142” -&gt; “5489355412”</li><li>交换下标 8 和下标 9 对应的位：”5489355412” -&gt; “5489355421”</li></ul><p>示例 2：</p><p>输入：num = “11112”, k = 4<br>输出：4<br>解释：第 4 个最小妙数是 “21111” ，要想得到这个数字：</p><ul><li>交换下标 3 和下标 4 对应的位：”11112” -&gt; “11121”</li><li>交换下标 2 和下标 3 对应的位：”11121” -&gt; “11211”</li><li>交换下标 1 和下标 2 对应的位：”11211” -&gt; “12111”</li><li>交换下标 0 和下标 1 对应的位：”12111” -&gt; “21111”</li></ul><p>示例 3：</p><p>输入：num = “00123”, k = 1<br>输出：1<br>解释：第 1 个最小妙数是 “00132” ，要想得到这个数字：</p><ul><li>交换下标 3 和下标 4 对应的位：”00123” -&gt; “00132”</li></ul><p>提示：</p><pre><code>2 &lt;= num.length &lt;= 10001 &lt;= k &lt;= 1000num 仅由数字组成</code></pre><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinSwaps</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=strTonums(num);</span><br><span class="line">        <span class="keyword">int</span>[] begin=nums.clone();</span><br><span class="line">        <span class="keyword">while</span>(k--&gt;<span class="number">0</span>)</span><br><span class="line">        nextPermutation(nums);</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; begin.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(begin[i]!=nums[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; begin.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==begin[j])</span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> q=j;q&gt;i;q--)</span><br><span class="line">                    &#123;</span><br><span class="line">                        swap(begin, q, q-<span class="number">1</span>);</span><br><span class="line">                        c++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> c;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] strTonums(String s) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> [] nums= <span class="keyword">new</span> <span class="keyword">int</span>[ch.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i]=ch[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=nums.length-<span class="number">2</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])i--;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> minindex=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = nums.length-<span class="number">1</span>; j &gt;i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[i]&amp;&amp;min&gt;nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    min=nums[j];</span><br><span class="line">                    minindex=j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            j=minindex;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            reverse(nums, i+<span class="number">1</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        reverse(nums, <span class="number">0</span> , nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><ol><li>找出第k个妙数</li><li>原来的数与第k个妙数对比,贪心,计算结果</li></ol><p>踩坑: 相邻的两个交换,之前这里错了  </p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>31. 下一个排列</title>
      <link href="/2021/07/30/leetcode/31/"/>
      <url>/2021/07/30/leetcode/31/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/next-permutation"> 31. 下一个排列</a>  </p><p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><p>示例 1：</p><p>输入：nums = [1,2,3]<br>输出：[1,3,2]</p><p>示例 2：</p><p>输入：nums = [3,2,1]<br>输出：[1,2,3]</p><p>示例 3：</p><p>输入：nums = [1,1,5]<br>输出：[1,5,1]</p><p>示例 4：</p><p>输入：nums = [1]<br>输出：[1]</p><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 1000 &lt;= nums[i] &lt;= 100</code></pre><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>,minj=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = nums.length - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxmin = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;<span class="comment">//找大数里面最小的数</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i] &amp;&amp; maxmin &gt; nums[j]) &#123;</span><br><span class="line">                    maxmin = nums[j];</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    minj=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = nums[i];</span><br><span class="line">                nums[i] = nums[minj];</span><br><span class="line">                nums[minj] = t;</span><br><span class="line">                Arrays.sort(nums, i + <span class="number">1</span>, nums.length);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><p>此方法更高效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=nums.length-<span class="number">2</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])i--;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> minindex=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = nums.length-<span class="number">1</span>; j &gt;i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[i]&amp;&amp;min&gt;nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    min=nums[j];</span><br><span class="line">                    minindex=j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            j=minindex;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            reverse(nums, i+<span class="number">1</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        reverse(nums, <span class="number">0</span> , nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li><p>下一个数比当前数大,将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。</p></li><li><p>下一个数增加的幅度尽可能的小</p><ol><li>在尽可能靠右的低位进行交换，需要从后向前查找<br> 将一个 尽可能小的「大数」 与前面的「小数」交换。</li><li>将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。</li></ol></li></ol><p>解法一自己写的,解法二是看了官方题解然后写的,他那个动画做的还蛮好的,感觉别人的代码写的真的高效且优雅,自己还是太菜了,orz…….</p><p>总结:</p><ol><li>找最小的大数比不上别人,我每个数都来一遍,人家是需要才进入二重循环找</li><li>人家直接reverse 时间复杂度O(n),我sort时间复杂度O(nlgn)</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 经典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1849. 将字符串拆分为递减的连续值</title>
      <link href="/2021/07/30/leetcode/1849/"/>
      <url>/2021/07/30/leetcode/1849/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values"> 1849. 将字符串拆分为递减的连续值</a></p><p>给你一个仅由数字组成的字符串 s 。</p><p>请你判断能否将 s 拆分成两个或者多个 非空子字符串 ，使子字符串的 数值 按 降序 排列，且每两个 相邻子字符串 的数值之 差 等于 1 。</p><pre><code>例如，字符串 s = &quot;0090089&quot; 可以拆分成 [&quot;0090&quot;, &quot;089&quot;] ，数值为 [90,89] 。这些数值满足按降序排列，且相邻值相差 1 ，这种拆分方法可行。另一个例子中，字符串 s = &quot;001&quot; 可以拆分成 [&quot;0&quot;, &quot;01&quot;]、[&quot;00&quot;, &quot;1&quot;] 或 [&quot;0&quot;, &quot;0&quot;, &quot;1&quot;] 。然而，所有这些拆分方法都不可行，因为对应数值分别是 [0,1]、[0,1] 和 [0,0,1] ，都不满足按降序排列的要求。</code></pre><p>如果可以按要求拆分 s ，返回 true ；否则，返回 false 。</p><p>子字符串 是字符串中的一个连续字符序列。</p><p>示例 1：</p><p>输入：s = “1234”<br>输出：false<br>解释：不存在拆分 s 的可行方法。  </p><p>示例 2：</p><p>输入：s = “050043”<br>输出：true<br>解释：s 可以拆分为 [“05”, “004”, “3”] ，对应数值为 [5,4,3] 。<br>满足按降序排列，且相邻值相差 1 。</p><p>示例 3：</p><p>输入：s = “9080701”  </p><p>解释：不存在拆分 s 的可行方法。</p><p>示例 4：</p><p>输入：s = “10009998”<br>输出：true<br>解释：s 可以拆分为 [“100”, “099”, “98”] ，对应数值为 [100,99,98] 。<br>满足按降序排列，且相邻值相差 1 。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">splitString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">long</span> before = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;<span class="comment">// 枚举第一个数可能的情况</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                before = Long.valueOf(s.substring(<span class="number">0</span>, i));<span class="comment">// 得到第一个数的值</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">// 如果报异常，说明他的数据长度超过了Long类型的最大值，为19位或20位</span></span><br><span class="line">                <span class="keyword">if</span> (s.substring(<span class="number">0</span>, <span class="number">2</span>).equals(<span class="string">&quot;00&quot;</span>))<span class="comment">// 如果前面两位不为0，则那个数是一</span></span><br><span class="line">                    <span class="comment">// 个长度为17+位的一个数后面几位组成的数必不可能和他构成递减1的数字</span></span><br><span class="line">                    before = Long.valueOf(s.substring(<span class="number">2</span>, i));<span class="comment">// 反正前两位都是0了，前面两位就舍弃，这样处理就避免了溢出</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String q = s.substring(i);</span><br><span class="line">            dfs(before, q);<span class="comment">// 开始寻找</span></span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">long</span> before, String now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (now.length() &lt;= <span class="number">0</span>) &#123;<span class="comment">// 如果一直找到最后面，说明有</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> before1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= now.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                before1 = Long.valueOf(now.substring(<span class="number">0</span>, i));<span class="comment">// 和上面一样的处理方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (now.substring(<span class="number">0</span>, <span class="number">2</span>).equals(<span class="string">&quot;00&quot;</span>))</span><br><span class="line">                    before1 = Long.valueOf(now.substring(<span class="number">2</span>, i));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (before == before1 + <span class="number">1</span>) &#123;<span class="comment">// 如果这个数与上一个数构成单调递减1的关系，</span></span><br><span class="line">                <span class="comment">// 接着调用dfs函数寻找，如果找到最后面now长度为0，就说明有</span></span><br><span class="line">                String q = now.substring(i);</span><br><span class="line">                dfs(before1, q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>重新看了一下以前的题,一看题目好难啊,在仔细看看,想起自己以前写过一篇题解,然后去看了看,我只想感慨现在越来越菜了,还没有以前行了,害~</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1937. 扣分后的最大得分</title>
      <link href="/2021/07/30/leetcode/1937/"/>
      <url>/2021/07/30/leetcode/1937/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximum-number-of-points-with-cost">1937. 扣分后的最大得分</a>   </p><p>给你一个 m x n 的整数矩阵 points （下标从 0 开始）。一开始你的得分为 0 ，你想最大化从矩阵中得到的分数。</p><p>你的得分方式为：每一行 中选取一个格子，选中坐标为 (r, c) 的格子会给你的总得分 增加 points[r][c] 。</p><p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 r 和 r + 1 （其中 0 &lt;= r &lt; m - 1），选中坐标为 (r, c1) 和 (r + 1, c2) 的格子，你的总得分 减少 abs(c1 - c2) 。</p><p>请你返回你能得到的 最大 得分。</p><p>abs(x) 定义为：</p><pre><code>如果 x &gt;= 0 ，那么值为 x 。如果 x &lt; 0 ，那么值为 -x 。</code></pre><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>输入：points = [[1,2,3],[1,5,1],[3,1,1]]<br>输出：9<br>解释：<br>蓝色格子是最优方案选中的格子，坐标分别为 (0, 2)，(1, 1) 和 (2, 0) 。<br>你的总得分增加 3 + 5 + 3 = 11 。<br>但是你的总得分需要扣除 abs(2 - 1) + abs(1 - 0) = 2 。<br>你的最终得分为 11 - 2 = 9 。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j] =  points[i][j] + max&#123;dp[i-1][k] - abs(j -k)&#125;</span></span><br><span class="line">    <span class="comment">//dp[i][j]指取(i,j)下标的元素能达到的最大值</span></span><br><span class="line">    <span class="comment">//优化后变成</span></span><br><span class="line">    <span class="comment">//k&lt;=j k在j左边 dp[i][j] =  points[i][j] - j + max&#123;dp[i-1][k] + k&#125;</span></span><br><span class="line">    <span class="comment">//k&gt; j k在j右边 dp[i][j] =  points[i][j] + j + max&#123;dp[i-1][k] - k&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = points.length;</span><br><span class="line">        <span class="keyword">int</span> n = points[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">long</span>[] pre = <span class="keyword">new</span> <span class="keyword">long</span>[n];<span class="comment">//记录上一行的值</span></span><br><span class="line">        <span class="comment">//由于某行的dp值只与上一行的值有关，故只需要两个long[n]的数组作为dp数组做状态转移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point : points) &#123;</span><br><span class="line">            <span class="keyword">long</span>[] cur = <span class="keyword">new</span> <span class="keyword">long</span>[n];<span class="comment">//记录这一行的dp值</span></span><br><span class="line">            <span class="keyword">long</span> best = Long.MIN_VALUE;</span><br><span class="line">            <span class="comment">//正序遍历</span></span><br><span class="line">            <span class="comment">//为何要正序，因为这时是在k在j左边的情况，那么max&#123;dp[i-1][k] + k&#125;中的k可取[0,j]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                best = Math.max(best, pre[j] + j);<span class="comment">//相当于max&#123;dp[i-1][k] + k&#125;的操作</span></span><br><span class="line">                cur[j] = Math.max(cur[j], point[j] - j + best);</span><br><span class="line">            &#125;</span><br><span class="line">            best = Long.MIN_VALUE;</span><br><span class="line">            <span class="comment">//倒序遍历</span></span><br><span class="line">            <span class="comment">//为何要倒序，因为这时是k在j右边的情况，那么max&#123;dp[i-1][k] - k&#125;中的k可取[j,n-1]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                best = Math.max(best, pre[j] - j);<span class="comment">//再倒序遍历，找上一行最大的dp[i-1][k]-k</span></span><br><span class="line">                cur[j] = Math.max(cur[j], best + point[j] + j);</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(pre).max().getAsLong();<span class="comment">//在最后一层找最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>好难啊,我还是太菜了,感觉自己智商有问题,好难受啊……<br>先贴一个别人的解法,看了好久,还有一些迷糊,尤其是倒序遍历哪里.</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java时间日期相关</title>
      <link href="/2021/07/28/java/java_time_format/"/>
      <url>/2021/07/28/java/java_time_format/</url>
      
        <content type="html"><![CDATA[<h1 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import  java.util.*;</span><br><span class="line">import java.text.*;</span><br><span class="line"> </span><br><span class="line">public class DateDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line"> </span><br><span class="line">      Calendar c=Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;当前时间为: &quot; + ft.format(c.getTimeInMillis()));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">字母</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">G</td><td align="center">纪元标记</td><td align="center">AD</td></tr><tr><td align="center">y</td><td align="center">四位年份</td><td align="center">2001</td></tr><tr><td align="center">M</td><td align="center">月份</td><td align="center">July or 07</td></tr><tr><td align="center">d</td><td align="center">一个月的日期</td><td align="center">10</td></tr><tr><td align="center">h</td><td align="center">A.M./P.M. (1~12)格式小时</td><td align="center">12</td></tr><tr><td align="center">H</td><td align="center">一天中的小时 (0~23)</td><td align="center">22</td></tr><tr><td align="center">m</td><td align="center">分钟数</td><td align="center">30</td></tr><tr><td align="center">s</td><td align="center">秒数</td><td align="center">55</td></tr><tr><td align="center">S</td><td align="center">毫秒数</td><td align="center">234</td></tr><tr><td align="center">E</td><td align="center">星期几</td><td align="center">Tuesday</td></tr><tr><td align="center">D</td><td align="center">一年中的日子</td><td align="center">360</td></tr><tr><td align="center">F</td><td align="center">一个月中第几周的周几</td><td align="center">2 (second Wed. in July)</td></tr><tr><td align="center">w</td><td align="center">一年中第几周</td><td align="center">40</td></tr><tr><td align="center">W</td><td align="center">一个月中第几周</td><td align="center">1</td></tr><tr><td align="center">a</td><td align="center">A.M./P.M. 标记</td><td align="center">PM</td></tr><tr><td align="center">k</td><td align="center">一天中的小时(1~24)</td><td align="center">24</td></tr><tr><td align="center">K</td><td align="center">A.M./P.M. (0~11)格式小时</td><td align="center">10</td></tr><tr><td align="center">z</td><td align="center">时区</td><td align="center">Eastern Standard Time</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面向对象</title>
      <link href="/2021/07/28/java/java_face_basis/"/>
      <url>/2021/07/28/java/java_face_basis/</url>
      
        <content type="html"><![CDATA[<p>面向对象是一种对现实世界理解和抽象的方法，万事万物皆为对象<br>达到了软件工程的三个主要目标：<code>可重用性、灵活性和扩展性</code><br>在Java语言中，编程的基本单位是类，类可以实例化成多个对象。面向<br>对象的概念包括：封装、继承、多态、类和对象、接口、包、属性、方法、<br>构造方法、修饰符、上溯下溯造型、泛型等  </p><h1 id="四大特征"><a href="#四大特征" class="headerlink" title="四大特征"></a>四大特征</h1><ol><li>抽象：指从众多的事物中舍弃个别的、非本质的部分，提炼出我们所关注的、共同的、本质的部分的过程。   </li><li>封装：在Java中，类封装了属性、方法、构造方法、语句块、内部类等成员，可以通过权限修饰符来控制外部对类成员的可访问性，隐藏其实现细节。</li><li>继承：以已有的类为基础来创建一个新的子类，子类继承父类的所有特性，并可以在此基础上扩充自己的特性，从而构造出更为复杂的类型。继承很好地解决了软件的可重用性问题。</li><li>多态：指同一个实体同时具有多种形式，主要表现为方法的重载、方法的覆盖、对象的多态等三种形式。通过多态，就能对“通用情况”编程，而不是对“特定情况”进行编程。<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><code>类</code>（Class）是对一类相似事物的描述，侧重对同类事物的共性进行抽象、概括、归纳。<br><code>对象</code>（Object）也叫实例（Instance），万事万物皆为对象。对象是信息系统必须觉察到的问题域中的人或事物的抽象，突出个性、特殊。在Java中，对象是通过类的实例化来创建的。 </li></ol><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><p>参考自菜鸟教程<br>访问修饰符    </p><ul><li>default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li><li>public : 对所有类可见。使用对象：类、接口、变量、方法</li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>非访问修饰符  </li><li>static 修饰符，用来修饰类方法和类变量。</li><li>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li><li>abstract 修饰符，用来创建抽象类和抽象方法。</li><li>synchronized 和 volatile 修饰符，主要用于线程的编程。<h1 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2>Java采用<code>extends 父类名</code>的方式来实现单继承。Java采用<code>implements &lt;接口列表&gt;</code>的方式来间接实现多继承。<br>子类可以继承父类中除private之外的成员变量和方法，但不包括构造方法。在子类的类体中我们可以重写父类中的方法，增加新的属性和方法。所以，类除了自己的属性和方法外，还有从父类继承过来的属性和方法。<br>接口定义<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[接口修饰符] interface 接口名称 [extends 父接口列表]&#123;</span><br><span class="line">   //常量定义</span><br><span class="line">     //抽象方法的定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合与聚合"><a href="#组合与聚合" class="headerlink" title="组合与聚合"></a>组合与聚合</h2>组合关系：整体与部分之间具有<code>相同的生命周期</code>，联系非常紧密。例如：人的身体与头部、四肢、躯干之间就是组合关系。<br>聚合关系：成员组成一个整体，联系相对松散。例如：班级与班主任、学生之间就是聚合关系。<h1 id="this-and-super"><a href="#this-and-super" class="headerlink" title="this and super"></a>this and super</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2></li><li>调用本类的构造方法：<code>this([实参数列表]);</code></li><li>当局部变量与对象变量重名时,this用于区分局部变量和对象变量：this.成员变量;  <h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。<br>如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。 </li><li>调用父类的构造方法：<code>super([实参数列表]);</code>，调用父类的构造方法，只能出现在子类的构造方法中，且必须是第一行</li><li>调用父类的方法：super.成员方法([实参数列表]);<h1 id="覆盖与重载"><a href="#覆盖与重载" class="headerlink" title="覆盖与重载"></a>覆盖与重载</h1><h2 id="覆盖（Override）"><a href="#覆盖（Override）" class="headerlink" title="覆盖（Override）"></a>覆盖（Override）</h2>子类改变父类中的方法   </li><li>三个相同：方法名、形式参数、返回类型完全相同（返回类型可以是父类的派生类，java5之前要一样，java7以后可以不同）。</li><li>两个不能：不能抛出比父类更多的异常，不能不能缩小父类方法的访问权限。</li><li>不能交叉覆盖：static方法只能被static方法覆盖，非static方法只能被非static方法覆盖。</li><li>final方法不能被覆盖，否则不能通过编译。<h2 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h2></li><li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li><li>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</li><li>最常用的地方就是构造器的重载。<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2></li></ul><table><thead><tr><th align="center">区别点</th><th align="center">重载（Overload）</th><th align="center">覆盖（Override）</th></tr></thead><tbody><tr><td align="center">参数列表</td><td align="center">必须修改</td><td align="center">不能修改</td></tr><tr><td align="center">返回类型</td><td align="center">可以修改</td><td align="center">不能修改</td></tr><tr><td align="center">异常</td><td align="center">可以修改</td><td align="center">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td align="center">访问</td><td align="center">可以修改</td><td align="center">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><h1 id="上溯造型和下溯造型"><a href="#上溯造型和下溯造型" class="headerlink" title="上溯造型和下溯造型"></a>上溯造型和下溯造型</h1><p>子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋值给一个父类引用变量，这种语法现象被称为上溯造型。上溯造型发生后，通过类型强制转换回到原来的子类，这种语法现象被称为下溯造型。只有曾经上溯造型过的对象才能进行下溯造型。对象不允许不经 过上溯造型而直接下溯造型。否则运行时会抛出java.lang.ClassCastException。 </p><p>上溯造型的优点：我们可以把不同类型的子类上溯为同一个父类类型，方便我们统一处理它们。缺点：损失掉了子类新扩展增加的属性和方法（覆盖父类的方法不会损失掉）</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul><li>Error类: 指较少发生的内部系统错误，由JVM生成并抛出，包括动态链接失败、JVM内部错误、资源耗尽等严重情况，程序员无能为力，只能让程序终止。</li><li>Exception类: 解决由程序本身及环境所产生的异常，有补救或控制的可<br>能，程序员也可预先防范，增加程序的健壮性。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">... ...//可能产生异常的代码</span><br><span class="line">&#125;catch(异常类型1 异常对象1)&#123;</span><br><span class="line">... ...//异常处理代码</span><br><span class="line">&#125;catch(异常类型2 异常对象2)&#123;</span><br><span class="line">... ...//异常处理代码</span><br><span class="line">&#125;[finally&#123;</span><br><span class="line">... ...//不管异常发生与否都执行的代码</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>如果一个方法没有捕获可能引发的异常，就必须在方法首部声明可能发生异常，交由调用者来处理异常。<br>throws的语法格式：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;类修饰符&gt;&lt;返回值类型&gt;&lt;方法名&gt;([&lt;形式参数列表&gt;])[throws &lt;异常类型列表&gt;]&#123;</span><br><span class="line">     [&lt;语句&gt;]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux软件安装</title>
      <link href="/2021/07/27/linux/install_software/"/>
      <url>/2021/07/27/linux/install_software/</url>
      
        <content type="html"><![CDATA[<h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><p><code>./configure</code>：./configure是为了检测目标安装平台的特征，并且检查依赖的软件包是否可用或者是否缺少依赖软件包，configure事实上是个脚本，最终的目的是生成Makefile。<br><code>make</code>：编译源码包<br><code>make install</code>：正常编译完之后如果没有报错，就生成了可执行文件，make install指令就是将可执行文件放到指定目录并配置环境变量，允许我们在任何目录下使用这个软件     </p><h1 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h1><h2 id="sudo-apt-get-install-XXX"><a href="#sudo-apt-get-install-XXX" class="headerlink" title="sudo apt-get install XXX"></a>sudo apt-get install XXX</h2><p>一键安装并自动安装依赖<br><code>-y</code>：不要重复确认安装<br><code>-q</code>：静默安装，屏蔽低等级的log指令</p><h2 id="sudo-apt-get-remove-XXX"><a href="#sudo-apt-get-remove-XXX" class="headerlink" title="sudo apt-get remove XXX"></a>sudo apt-get remove XXX</h2><p>卸载软件，但不卸载配置文件</p><h2 id="sudo-apt-get-purge-XXX"><a href="#sudo-apt-get-purge-XXX" class="headerlink" title="sudo apt-get purge XXX"></a>sudo apt-get purge XXX</h2><p>卸载软件，且卸载相应的配置文件</p><h2 id="sudo-apt-get-autoremove"><a href="#sudo-apt-get-autoremove" class="headerlink" title="sudo apt-get autoremove"></a>sudo apt-get autoremove</h2><p>卸载的同时也卸载依赖，慎用</p><h2 id="sudo-apt-get-update"><a href="#sudo-apt-get-update" class="headerlink" title="sudo apt-get update"></a>sudo apt-get update</h2><p>更新所有包的来源</p><h2 id="sudo-apt-get-upgrade"><a href="#sudo-apt-get-upgrade" class="headerlink" title="sudo apt-get upgrade"></a>sudo apt-get upgrade</h2><p>升级所有包，慎用   </p><h2 id="sudo-apt-get-upgrade-XXX"><a href="#sudo-apt-get-upgrade-XXX" class="headerlink" title="sudo apt-get upgrade XXX"></a>sudo apt-get upgrade XXX</h2><p>升级某个包</p><h2 id="apt-get-dist-upgrade"><a href="#apt-get-dist-upgrade" class="headerlink" title="apt-get dist-upgrade"></a>apt-get dist-upgrade</h2><p>升级系统版本</p><h2 id="apt-list-–upgradable"><a href="#apt-list-–upgradable" class="headerlink" title="apt list –upgradable"></a>apt list –upgradable</h2><p>列出可更新软件    </p><h1 id="snap"><a href="#snap" class="headerlink" title="snap"></a>snap</h1><p>Snap是Canonical推出的一种新的软件打包格式，彻底解决linux依赖性的问题，Snap 软件包拥有更加稳定和安全的特性。snap也就是安装snap软件包的命令。</p><p>如果您正在运行Ubuntu 16.04 LTS或更高版本，您可以在命令行中使用snap。</p><h2 id="sudo-snap-list"><a href="#sudo-snap-list" class="headerlink" title="sudo snap list"></a>sudo snap list</h2><p>列出计算机上所有snap安装情况： </p><h2 id="sudo-snap-find-lt-软件包名-gt"><a href="#sudo-snap-find-lt-软件包名-gt" class="headerlink" title="sudo snap find &lt;软件包名&gt;"></a>sudo snap find &lt;软件包名&gt;</h2><p>在应用商店中查找snap：</p><h2 id="sudo-snap-install-lt-snap软件包名-gt"><a href="#sudo-snap-install-lt-snap软件包名-gt" class="headerlink" title="sudo snap install &lt;snap软件包名&gt;"></a>sudo snap install &lt;snap软件包名&gt;</h2><p>安装Snap软件：</p><h2 id="sudo-snap-refresh-lt-snap软件包名-gt"><a href="#sudo-snap-refresh-lt-snap软件包名-gt" class="headerlink" title="sudo snap refresh &lt;snap软件包名&gt;"></a>sudo snap refresh &lt;snap软件包名&gt;</h2><p>更新Snap软件：</p><h2 id="sudo-snap-refresh-all"><a href="#sudo-snap-refresh-all" class="headerlink" title="sudo snap refresh all"></a>sudo snap refresh all</h2><p>更新所有的snap软件包：</p><h2 id="sudo-snap-revert-lt-snap软件包名-gt"><a href="#sudo-snap-revert-lt-snap软件包名-gt" class="headerlink" title="sudo snap revert &lt;snap软件包名&gt;"></a>sudo snap revert &lt;snap软件包名&gt;</h2><p>要将Snap还原到以前安装的版本：</p><h2 id="sudo-snap-remove-lt-snap软件包名-gt"><a href="#sudo-snap-remove-lt-snap软件包名-gt" class="headerlink" title="sudo snap remove &lt;snap软件包名&gt;"></a>sudo snap remove &lt;snap软件包名&gt;</h2><p>卸载snap软件：</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/downey-blog/p/10473893.html">apt-get的使用及原理</a><br><a href="https://ipcmen.com/snap">snap用法</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux环境变量</title>
      <link href="/2021/07/27/linux/add_env_path/"/>
      <url>/2021/07/27/linux/add_env_path/</url>
      
        <content type="html"><![CDATA[<h1 id="临时"><a href="#临时" class="headerlink" title="临时"></a>临时</h1><p>XXX 表示所配置环境变量的路径<br><code>export PATH=XXX:$PATH</code></p><h1 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h1><p>打开~/.bashrc<br>添加 <code>export PATH=XXX:$PATH</code><br>使生效 <code>source .bashrc</code></p><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><p>打开 /etc/profile<br>添加 <code>export PATH=XXX:$PATH</code><br>使生效 <code>source profile</code>    </p><h1 id="source"><a href="#source" class="headerlink" title="source"></a>source</h1><p>source命令也称为“点命令”，也就是一个点符号（.）。source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。因为linux所有的操作都会变成文件的格式存在。   </p><p>source filename 或 . filename</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/jpfss/p/11107080.html">linux环境变量配置详解</a><br><a href="https://www.cnblogs.com/qlqwjy/p/8684063.html">source命令</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基本指令</title>
      <link href="/2021/07/27/linux/linux1/"/>
      <url>/2021/07/27/linux/linux1/</url>
      
        <content type="html"><![CDATA[<h1 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h1><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>-l：表示list，表示以详细列表的形式进行展示<br>-a：表示显示所有的文件/文件夹（包含了隐藏文件/文件夹）</p><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>打印当前路径  </p><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>mkdir -p 一次性创建多层不存在的目录<br>mkdir 路径1 路径2 路径3 … 表示一次性创建多个目录 </p><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>文件名或路径</p><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>cp 被复制的文档路径 文档被复制到的路径<br>注意：Linux在复制过程中是可以重新对新位置的文件进行重命名的，但是如果不是必须的需要，则建议保持前后名称一致。<br>案例：使用cp命令来复制一个文件夹<br>注意：当使用cp命令进行文件夹复制操作的时候需要添加选项“-r”【-r表示递归复制】，否则目录将被忽略</p><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>-f：force，强制删除，不提示是否删除<br>-r：表示递归<br>-rf<br>案例：要删除一个目录下有公共特性的文档，例如都以Linux开头<br>rm -rf linux*<br>星号称之为通配符，意思表示任意的字符，Linux*，则表示只要文件以Linux开头，后续字符则不管。  </p><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>1.&gt;：覆盖输出，会覆盖掉原先的文件内容<br>2.&gt;&gt;：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加<br>语法：#正常执行的指令 &gt; / &gt;&gt; 文件的路径<br>注意：文件可以不存在，不存在则新建  </p><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>作用1：cat有直接打开一个文件的功能。<br>语法1：#cat 文件的路径<br>作用2：cat还可以对文件进行合并<br>语法2：#cat 待合并的文件路径1 待合并的文件路径2 …. 文件路径n &gt; 合并之后的文件路径</p><h1 id="进阶指令"><a href="#进阶指令" class="headerlink" title="进阶指令"></a>进阶指令</h1><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>作用：查看磁盘的空间<br>语法：#df -h        -h表示以可读性较高的形式展示大小</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>作用：查看内存使用情况<br>语法：#free -m   -m表示以mb为单位查看  </p><h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>作用：查看一个文件的前n行，如果不指定n，则默认显示前10行。<br>语法：#head -n 文件路径   【n表示数字】  </p><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>作用1：查看一个文件的未n行，如果n不指定默认显示后10行<br>语法：#tail -n 文件的路径    n同样表示数字<br>作用2：可以通过tail指令来查看一个文件的动态变化内容【变化的内容不能是用户手动增加的】<br>语法：#tail -f 文件路径<br>该命令一般用于查看系统的日志比较多。  </p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>作用：查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车、空格键+上下方向键）查看更多<br>语法：#less 需要查看的文件路径<br>在退出的只需要按下q键即可。  </p><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>作用：统计文件内容信息（包含行数、单词数、字节数）<br>语法：#wc -lwc 需要统计的文件路径<br>    -l：表示lines，行数<br>    -w：表示words，单词数   依照空格来判断单词数量<br>    -c：表示bytes，字节数  </p><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>作用：表示操作时间日期（读取、设置）<br>语法1：#date            输出的形式：2018年 3月 24日 星期六 15:54:28<br>语法2：#date  +%F    （等价于#date  “+%Y-%m-%d” ）    输出形式：2018-03-24<br>语法3：#date  “+%F %T”    引号表示让“年月日与时分秒”成为一个不可分割的整体<br>等价操作#date  “+%Y-%m-%d %H:%M:%S”<br>输出的形式：2018-03-24 16:01:00<br>语法4：获取之前或者之后的某个时间（备份）<br>date  -d  “-1 day”  “+%Y-%m-%d %H:%M:%S”<br>符号的可选值：+（之后） 或者 - （之前）<br>单位的可选值：day（天）、month（月份）、year（年）<br>%F：表示完整的年月日<br>%T：表示完整的时分秒<br>%Y：表示四位年份<br>%m：表示两位月份（带前导0）<br>%d：表示日期（带前导0）<br>%H：表示小时（带前导0）<br>%M：表示分钟（带前导0）<br>%S：表示秒数（带前导0）  </p><h2 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h2><p>作用：用来操作日历的<br>语法1：#cal      等价于 #cal  -1        直接输出当前月份的日历<br>语法2：#cal  -3            表示输出上一个月+本月+下个月的日历<br>语法3：#cal  -y 年份          表示输出某一个年份的日历  </p><h2 id="clear-ctrl-L"><a href="#clear-ctrl-L" class="headerlink" title="clear == ctrl + L"></a>clear == ctrl + L</h2><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道符：|<br>作用：管道一般可以用于“过滤”，“特殊”，“扩展处理”。<br>语法：管道不能单独使用，必须需要配合前面所讲的一些指令来一起使用，其作用主要是辅助作用。  </p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p> grep 的作用是在文件中提取和匹配符合条件的字符串行。命令格式如下：<br>  grep  -A “搜索内容” 文件名<br>选项：  </p><p>-A 数字：列出符合条件的行，并列出后续的 n 行；<br>-B 数字：列出符合条件的行，并列出前面的 n 行；<br>-c：统计找到的符合条件的字符串的次数；<br>-i：忽略大小写；<br>-n：输出行号；<br>-v：反向査找；<br>–color=auto：搜索出的关键字用颜色显示；<br><a href="https://www.cnblogs.com/lizhouwei/p/9991827.html">https://www.cnblogs.com/lizhouwei/p/9991827.html</a><br><a href="https://blog.csdn.net/weixin_34366546/article/details/93424831">https://blog.csdn.net/weixin_34366546/article/details/93424831</a>  </p><h2 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h2><p>作用：操作服务器的主机名（读取、设置）<br>语法1：#hostname            含义：表示输出完整的主机名<br>语法2：#hostname  -f            含义：表示输出当前主机名中的FQDN（全限定域名）  </p><h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><p>作用：查看一个用户的一些基本信息（包含用户id，用户组id，附加组id…），该指令如果不指定用户则默认当前用户。<br>语法1：#id        默认显示当前执行该命令的用户的基本信息<br>语法2：#id  用户名        显示指定用户的基本信息  </p><h2 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h2><p>显示当前登录的用户名  </p><h2 id="ps-ef"><a href="#ps-ef" class="headerlink" title="ps -ef"></a>ps -ef</h2><p>-e：等价于“-A”，表示列出全部的进程<br>-f：显示全部的列（显示全字段）<br>#ps -ef|grep “进程名称”  </p><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>作用：查看服务器的进程占的资源（100%使用）<br>语法：<br>    进入命令：#top            （动态显示）<br>    退出命令：按下q键  </p><h2 id="du-sh"><a href="#du-sh" class="headerlink" title="du -sh"></a>du -sh</h2><p>作用：查看目录的真实大小<br>语法：#du -sh 目录路径<br>选项含义：<br>    -s：summaries，只显示汇总的大小<br>    -h：表示以高可读性的形式进行显示  </p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>作用：用于查找文件（其参数有55个之多）<br>语法：#find 路径范围 选项 选项的值<br>选项：<br>    -name：按照文档名称进行搜索（支持模糊搜索）<br>    -type：按照文档的类型进行搜索<br>        文档类型：“-”表示文件（在使用find的时候需要用f来替换），“d”表示文件夹</p><p>案例：使用find来搜索httpd.conf<br>#find / -name httpd.conf  </p><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>作用：用于控制一些软件的服务启动/停止/重启<br>语法：#service 服务名 start/stop/restart</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>作用：表示杀死进程        （当遇到僵尸进程或者出于某些原因需要关闭进程的时候）<br>语法：#kill  进程PID        （语法需要配合ps一起使用）  </p><h2 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h2><p>与kill命令作用相似但是比kill更加好用的杀死进程的命令：killall<br>语法：#killall 进程名称</p><h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><p>获取网卡信息</p><h2 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h2><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><p>init 0<br>halt<br>poweroff<br>这些命令都可以关机   </p><h2 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h2><p>作用：输出计算机的持续在线时间（计算机从开机到现在运行的时间）<br>语法：#uptime</p><h2 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h2><p>作用：获取计算机操作系统相关信息<br>语法1：#uname            获取操作系统的类型<br>语法2：#uname  -a        all，表示获取全部的系统信息（类型、全部主机名、内核版本、发布时间、开源计划）</p><h2 id="netstat-tnlp"><a href="#netstat-tnlp" class="headerlink" title="netstat -tnlp"></a>netstat -tnlp</h2><p>-r 路由表<br>作用：查看网络连接状态<br>语法：#netstat -tnlp<br>选项说明：   </p><ul><li>-t：表示只列出tcp协议的连接；</li><li>-n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示；</li><li>-l：表示过滤出“state（状态）”列中其值为LISTEN（监听）的连接；</li><li>-p：表示显示发起连接的进程pid和进程名称；</li></ul><h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>指令用法</p><h1 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h1><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>与该级别相关的几个命令：<br>#init 0 表示关机<br>#init 3 表示切换到不带桌面的模式<br>#init 5 切换到图形界面<br>#init 6 重启电脑   </p><p>注意：init指令需要超级管理员的权限，普通用户无法执行。   </p><p>这些命令其实都是调用的init进程，将数字（运行级别）传递给进程，进程去读配置文件执行对应的操作。   </p><h2 id="关于ubuntu-root密码问题"><a href="#关于ubuntu-root密码问题" class="headerlink" title="关于ubuntu root密码问题"></a>关于ubuntu root密码问题</h2><p>sudo passwd 回车后按照操作设置unix密码</p><h1 id="用户与用户组管理"><a href="#用户与用户组管理" class="headerlink" title="用户与用户组管理"></a>用户与用户组管理</h1><p>/etc/passwd                存储用户的关键信息<br>/etc/group                存储用户组的关键信息<br>/etc/shadow                存储用户的密码信息    </p><h2 id="etc-passwd文件"><a href="#etc-passwd文件" class="headerlink" title="/etc/passwd文件"></a>/etc/passwd文件</h2><p>用户名:密码:用户ID:用户组ID:注释:家目录:解释器shell      </p><p>用户名：创建新用户名称，后期登录的时候需要输入；<br>密码：此密码位置一般情况都是“x”，表示密码的占位；<br>用户ID：用户的识别符；<br>用户组ID：该用户所属的主组ID；<br>注释：解释该用户是做什么用的；<br>家目录：用户登录进入系统之后默认的位置；<br>解释器shell：等待用户进入系统之后，用户输入指令之后，该解释器会收集用户输入的指令，传递给内核处理；   </p><h2 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h2><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。<br>文件结构：<br>用户组名:密码:用户组ID:组内用户名   </p><h2 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h2><p>常用语法：#useradd 选项 用户名<br>常用选项：<br>    -g：表示指定用户的用户主组，选项的值可以是用户组的id，也可以是组名<br>    -G：表示指定用户的用户附加组，选项的值可以是用户组的id，也可以是组名<br>    -u：uid，用户的id（用户的标识符），系统默认会从500之后按顺序分配uid，如果不想使用系统分配的，可以通过该选项自定义<br>    -c comment：添加注释<br>注意：<br>在不添加选项的时候，执行useradd之后会执行一系列的操作<br>    a. 创建同名的家目录；<br>    b. 创建同名的用户组；<br>注意：<br>查看用户的主组可以查看passwd文件，查看附加组可以查看group文件。   </p><p>验证是否成功：<br>    a. 验证/etc/passwd的最后一行，查看是否有zhangsan的信息；<br>    b. 验证是否存在家目录（在Centos下创建好用户之后随之产生一个同名家目录）；</p><h2 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h2><p>修改用户<br>常用语法： usermod 选项 用户名   </p><p>常用选项：<br>    -g：表示指定用户的用户主组，选项的值可以是用户组的id，也可以是组名<br>    -G：表示指定用户的用户附加组，选项的值可以是用户组的id，也可以是组名<br>    -u：uid，用户的id（用户的标识符），系统默认会从500之后按顺序分配uid，如果不想使用系统分配的，可以通过该选项自定义【类似于腾讯QQ的自选靓号情况】<br>    -l：修改用户名   </p><p>案例：修改zhangsan用户主组为500，附加组改为501<br>#usermod -g 500 -G 501 zhangsan<br>案例：修改zhangsan用户用户名，改为wangerma<br>#usermod -l 新的用户名 旧的用户名<br>#usermod -l wangerma zhangsan   </p><h2 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h2><p>修改密码<br>#passwd 用户名</p><h2 id="usersel"><a href="#usersel" class="headerlink" title="usersel"></a>usersel</h2><p>常用语法：#userdel 选项 用户名<br>    -r：表示删除用户的同时，删除其家目录；<br>注意：<br>已经登录的wangerma用户删除的时候提示删除失败，但是没有登录的用户可以正常删除。</p><p>解决办法：简单粗暴，kill对应用户的全部进程</p><h2 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h2><p>常用语法：#groupadd 选项 用户组名<br>常用选项：<br>    -g：类似用户添加里的“-u”，-g表示选择自己设置一个自定义的用户组ID数字，如果自己不指定，则默认从500之后递增；   </p><h2 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h2><p>常用语法：#groupmod 选项 用户组名<br>常用选项：<br>    -g：类似用户修改里的“-u”，-g表示选择自己设置一个自定义的用户组ID数字<br>    -n：类似于用户修改“-l”，表示设置新的用户组的名称<br>案例：修改Administrators用户组，将组ID从502改成520，将名称改为admins</p><h2 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h2><p>常用语法：#groupdel 用户组名<br>注意：当如果需要删除一个组，但是这个组是某个用户的主组时，则不允许删除；如果确实需要删除，则先从组内移出所有用户。</p><h1 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h1><h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h2><p>ln -s 原始文件的路径 快捷方式的路径   </p><h2 id="ifconfig-1"><a href="#ifconfig-1" class="headerlink" title="ifconfig"></a>ifconfig</h2><h2 id="ifdown"><a href="#ifdown" class="headerlink" title="ifdown"></a>ifdown</h2><p>停止某个网卡：#ifdown 网卡名</p><h2 id="ifup"><a href="#ifup" class="headerlink" title="ifup"></a>ifup</h2><p>开启某个网卡：#ifup 网卡名</p><h1 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h1><h2 id="sudo-dpkg-i-xxxxx"><a href="#sudo-dpkg-i-xxxxx" class="headerlink" title="sudo dpkg -i xxxxx"></a>sudo dpkg -i xxxxx</h2><p>安装命令</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法课题小结</title>
      <link href="/2021/07/27/little_thing/algorithm/"/>
      <url>/2021/07/27/little_thing/algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="无线传感网络"><a href="#无线传感网络" class="headerlink" title="无线传感网络"></a>无线传感网络</h1><h2 id="粒子群算法（鸟群算法）"><a href="#粒子群算法（鸟群算法）" class="headerlink" title="粒子群算法（鸟群算法）"></a>粒子群算法（鸟群算法）</h2><p>设由 m个粒子组成的群体对Q 维空间（即每个粒子的维数）进行搜索。粒子i的位置表示为：Xi = (xi1，xi2  …  xiQ)，粒 子 i 对应的速度表示为 Vi = (vi1 ，vi2 ，…  viQ) ，每个粒子在搜索时要考虑两个因素：  </p><ol><li>搜索过的历史最优值  </li><li>搜索到的所有最优值   </li></ol><p>粒子跟踪自己历史最优值和粒子跟踪群体最优值的权重系数，通常设置为 γ1 和γ2 ,是区间[0，1]内均匀分布的随机数；W表示为惯性权值。寻优过程中，应对微粒的速度Vi和位置Xi进行范围限制，粒子i的各维速度分向量和位置分向量的有效区间分别为：viQ [vmin ，vmax] ，xiQ [xmin ，xmax] 。 其中，vmin = -rand × xmax ，vmax = rand × xmax ，rand 表示 [0，1] 之间的随机数。当 viQ 离开这个范围，可将 viQ 设为 vmin 或者 vmax 。<br>对惯性全值的优化：<br>较大的惯性权值W可以加强粒子群算法的全局搜索能力，而较小的惯性权值W能加强粒子群算法的的局部搜索能力。且粒子群算法的早期收敛非常快。所以应尽快让算法进入局部搜索，才能获得更高的求解效率。<br>粒子群算法在寻优过程中容易陷入局部最优解。为了减少局部最优的陷阱，在粒子进化过程中，加入虚拟库仑力作为扰动因子来增强粒子群算法的节点位置更新能力，提高算法的收敛速度和整个网络的覆盖率。</p><h2 id="花粉算法"><a href="#花粉算法" class="headerlink" title="花粉算法"></a>花粉算法</h2><p><img src="https://gitee.com/aqeb/cnblog/raw/master/%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%89%87/%E8%8A%B1%E7%B2%89%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="花粉算法流程图"></p><h1 id="垃圾分类"><a href="#垃圾分类" class="headerlink" title="垃圾分类"></a>垃圾分类</h1><p>感觉算法和使用的模型有一点乱，不好提炼，我也觉得它不会考，就不写了。</p><h1 id="粮食预测"><a href="#粮食预测" class="headerlink" title="粮食预测"></a>粮食预测</h1><h2 id="自回归滑动平均模型-AR-MA-的时间序列分析预测粮食产量-："><a href="#自回归滑动平均模型-AR-MA-的时间序列分析预测粮食产量-：" class="headerlink" title="自回归滑动平均模型(AR-MA)的时间序列分析预测粮食产量 ："></a>自回归滑动平均模型(AR-MA)的时间序列分析预测粮食产量 ：</h2><p>时间序列是统计某一个指标在不同时间上的各个数值，按时间先后顺序排列而形成的序列。通过对一个区域进行一定时间段内的连续遥感观测，提取图像有关特征，并分析其变化过程与发展规模，综合趋势、周期、时期和不稳定因素四种因素，预测出结果。即根据事物发展的延续性，应用过去数据，再根据事物发展的随机性，应用加权平均法，推测事物的发展趋势。<br>时间序列建模基本步骤是：用观测、调查、统计、抽样等方法取得现实的、真实的一组数据；再根据动态数据进行相关分析，建立自相关函数模型，显示变化的趋势和周期以及跳点和拐点；测试及确定其适用性。</p><h2 id="基于灰色-马尔科夫模型的粮食产量预测-10"><a href="#基于灰色-马尔科夫模型的粮食产量预测-10" class="headerlink" title="基于灰色-马尔科夫模型的粮食产量预测[10]"></a>基于灰色-马尔科夫模型的粮食产量预测[10]</h2><p>如果一个系统具有层次、结构关系的模糊性，动态变化的随机性，指标数据的不完备或不确定性，则称这些特性为灰色性。具有灰色性的系统称为灰色系统。对灰色系统建立的预测模型称为灰色模型(Grey Model)，简称GM模型。<br>由于粮食生产具有明显的灰度特征，因此可以使用灰色模型预测粮食产量。传统的灰色模型虽然能有效地预测少量数据的序列，但随着数据的增多和波动性的增大，该模型逐渐失去了它的优势，而马尔科夫模型预测可以应用于随机变化的时间序列中，弥补灰色模型的不足。因此，采用灰色 － 马尔科夫模型可以实现对粮食产量进行短期精准预测。<br><img src="https://gitee.com/aqeb/cnblog/raw/master/%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%89%87/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E7%B2%AE%E9%A3%9F%E9%A2%84%E6%B5%8B.png" alt="粮食预测马尔可夫流程图">  </p><h2 id="回归线性方程在粮食产量预测中的应用"><a href="#回归线性方程在粮食产量预测中的应用" class="headerlink" title="回归线性方程在粮食产量预测中的应用"></a>回归线性方程在粮食产量预测中的应用</h2><ol><li>建立模型</li><li>模型求解与检验  </li><li>拟合度测定</li><li>估计标准误差<h1 id="旅行照片风格图像化"><a href="#旅行照片风格图像化" class="headerlink" title="旅行照片风格图像化"></a>旅行照片风格图像化</h1>我觉得这个考的几率也不大<h2 id="基于最大均值差异的风格迁移"><a href="#基于最大均值差异的风格迁移" class="headerlink" title="基于最大均值差异的风格迁移"></a>基于最大均值差异的风格迁移</h2>虽然是自己的课题，但我也看不懂，就不提炼了<h2 id="基于马尔科夫随机场的风格迁移"><a href="#基于马尔科夫随机场的风格迁移" class="headerlink" title="基于马尔科夫随机场的风格迁移"></a>基于马尔科夫随机场的风格迁移</h2>马尔可夫随机场是非参数图像合成的经典框架，它描述了具有同类特征 信息的集合。将图像特征映射分割成许多区域块并进行匹配，以提高合成图像在视觉上的合理性。<h2 id="基于深度图像类比的风格迁移"><a href="#基于深度图像类比的风格迁移" class="headerlink" title="基于深度图像类比的风格迁移"></a>基于深度图像类比的风格迁移</h2>图像类比的概念与深度学习结合提出了 一种通过区域块匹配迭代优化的深度图像类比方法。这种方法可以将图像 类比的概念应用到深层网络特征空间中，寻找语义上有意义的 稠密对应关 系，从而提高图像风格迁移的有效性。 深度图像类比的映射关系可以表示为 A ∶ A* ∶ ∶ B ∶ B* ，其 中， A* 和 B 为未知变量。在这个映射关系中具有两个约束条 件:A 和 A* 或 B 和 B* 具有相似的图像内容特征;A 和 B 或 A* 和 B* 具有相似的图像风 格特征。因此，图像映射关系可表示 为 A(p) = B(φa→b ( p))和 A* ( p) = B* (φa→b ( p))。φb→a 表示 逆映射，则有 φb→a (φa→b(p)) = p 和 φa→b(φb→a (p)) = p。 深度图像类比方法首先使用预训练 VGG 模型分别计算出 已知图像 A 和 B* 的各层抽象特征表示 FL A 和 FL B* ，其中，L 表 示使用预训练 VGG 模 型中的层数。在第 L 层中可以通过最近 邻域搜索(nearest neighbor field search，NNFS)求得深度图像类 比的映射关系。</li></ol><p>PatchMatch 是图像类比的经典算法：给定一组图片 A 和 B’，A 提供语 义和内容两大主要信息，B’提供外观性（例如颜色、光照、风格等）和细 节（例如纹理）信息，将两张图片都划分为固定大小的像素块，对于 A 中的 每一个像素块，在 B’中寻找与之最相近的像素块来代替。当像素块足够小， 且全部替代完成后进行平滑等处理后，即刻获得用 B’的风格表现 A 的风格</p><h1 id="多目标方法解决旅游线路规划"><a href="#多目标方法解决旅游线路规划" class="headerlink" title="多目标方法解决旅游线路规划"></a>多目标方法解决旅游线路规划</h1><p>（个人感觉这个是重点）</p><h2 id="线性加权遗传算法"><a href="#线性加权遗传算法" class="headerlink" title="线性加权遗传算法"></a>线性加权遗传算法</h2><p>线性加权法是在对各个目标函数进行分析的基础上，将多目标问题的各个目标函数按其重要程度分别赋予它们一个权重，然后多个目标函数加权运算来构造评价函数．</p><p><img src="https://gitee.com/aqeb/cnblog/raw/master/%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%89%87/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%97%85%E6%B8%B8%E8%B7%AF%E5%BE%84.png" alt="遗传算法路劲规划"></p><h2 id="蚁群算法"><a href="#蚁群算法" class="headerlink" title="蚁群算法"></a>蚁群算法</h2><p>（我觉得这个可能性比较大）  </p><ol><li><p>算法介绍<br>蚁群算法是用来寻找优化路径的概率型算法。<br>这种算法具有分布计算、信息正反馈和启发式搜索的特征，本质上是进化算法中的一种启发式全局优化算法。<br>蚂蚁会在其经过的路径上释放一种可以称之为“信息素”的物质，蚁群内的蚂蚁对“信息素”具有感知能力，它们会沿着“信息素”浓度较高路径行走，而每只路过的蚂蚁都会在路上留下“信息素”，这就形成一种类似正反馈的机制，这样经过一段时间后，整个蚁群就会沿着最短路径到达食物源了。</p></li><li><p>算法原理<br>将蚁群算法应用于解决优化问题的基本思路为：用蚂蚁的行走路径表示待优化问题的可行解，整个蚂蚁群体的所有路径构成待优化问题的解空间。路径较短的蚂蚁释放的信息素量较多，随着时间的推进，较短的路径上累积的信息素浓度逐渐增高，选择该路径的蚂蚁个数也愈来愈多。最终，整个蚂蚁会在正反馈的作用下集中到最佳的路径上，此时对应的便是待优化问题的最优解。</p></li><li><p>实现方法<br>蚂蚁找到最短路径要归功于信息素和环境，假设有两条路可从蚁窝通向食物，开始时两条路上的蚂蚁数量差不多：当蚂蚁到达终点之后会立即返回，距离短的路上的蚂蚁往返一次时间短，重复频率快，在单位时间里往返蚂蚁的数目就多，留下的信息素也多，会吸引更多蚂蚁过来，会留下更多信息素。而距离长的路正相反，因此越来越多的蚂蚁聚集到最短路径上来。</p></li><li><p>优点</p><ul><li>采用正反馈机制，使得搜索过程不断收敛，最终逼近最优解。</li><li>每个个体可以通过释放信息素来改变周围的环境，且每个个体能够感知周围环境的实时变化，个体间通过环境进行间接地通讯。</li><li>搜索过程采用分布式计算方式，多个个体同时进行并行计算，大大提高了算法的计算能力和运行效率。</li><li>启发式的概率搜索方式不容易陷入局部最优，易于寻找到全局最优解。</li></ul></li></ol><p>在移动过程中，主要参照各条路径上的信息素浓度，以此来决定转移方向。这种转移规则被称之为随机比例规则<br><img src="https://gitee.com/aqeb/cnblog/raw/master/%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%89%87/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95.png" alt="蚁群算法流程"></p><p>优化算法：灰狼算法。（还可以看看模拟退火）<br>仔细观察狼群围捕过程可以发现，在围捕的最后阶段狼群围绕猎物不断移动，但代价函数的输出却不再缩小，究其原因是狼群多样性缺失，α狼陷入局部最优，为此，本文提出为α狼增加主动搜索视野，使α狼不再被动局限于狼群更新带来的优化，同时也具备局部搜索的能力。    假设α狼具备看到β狼的视野，这样每次α狼、β狼、δ狼更新位置后α狼会在视野范围内寻找比当前更优的位置并移动到更优位置，为了减少参数数量，假设α狼每次视野内局部寻优进行次数与狼群迭代次数相同，即程序会在α狼视野范围内重复生成备选位置，与α狼比较并选取最优解。</p><h1 id="旅游攻略语义"><a href="#旅游攻略语义" class="headerlink" title="旅游攻略语义"></a>旅游攻略语义</h1><p>（大概看了一下申请书，感觉不会考，主要是我看不懂，好像算法什么的少，主要是网络模型，和垃圾分类一样）</p><h1 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h1><h2 id="Q-Learning-算法"><a href="#Q-Learning-算法" class="headerlink" title="Q-Learning 算法"></a>Q-Learning 算法</h2><p>Q -learning 算法首先建立一张 Q 值表，Agent 通过不断地狱环境交互，得<br>到反馈，对 Agent 的状态一动作对形成奖赏值，通过不断的迭代修改查抄表，<br>会使选择正奖赏的动作的概率会不断增加，而相应的得到负奖赏的动作的概率<br>会有不断减小的趋势，随着不断的与环境交互迭代筛选，更改动作策略集，会<br>使智能体的动作集最终趋于最优动作集。还有遗忘机制</p><h2 id="Sarsa-算法"><a href="#Sarsa-算法" class="headerlink" title="Sarsa 算法"></a>Sarsa 算法</h2><p>其基本原理为:如果强化学习系统的某种行为能够获得环境正的奖赏, 那么系统<br>便会加强产生该动作的趋势, 这称之为正反馈过程;反之，系统便会减弱产生该<br>动作的趋势。</p><h2 id="深度确定性策略梯度算法"><a href="#深度确定性策略梯度算法" class="headerlink" title="深度确定性策略梯度算法"></a>深度确定性策略梯度算法</h2><p>该算法在策略梯度算法的基础上，算法模拟的输入为状态空间，输<br>出不再是每个动作的概率，而是该状态空间对应的具体动作。</p><h1 id="多机器人路径规划和编队"><a href="#多机器人路径规划和编队" class="headerlink" title="多机器人路径规划和编队"></a>多机器人路径规划和编队</h1><h2 id="VHF算法"><a href="#VHF算法" class="headerlink" title="VHF算法"></a>VHF算法</h2><p>VHF算法是一种基于未知威胁的动态航路搜索算法，实现简单，并且能够保证得到最优路径等优点。VHF算法由于其避障效率高等优点经常使用在机器人的实时避障上，但是不能保证规划的路径的最佳性能。<br>VFH路径规划算法是通过机器人自带传感器实时检测在视野范围内的障碍物，并实时的更新网状直方图的数据，由二维的笛卡尔网格直方图映射转化魏一维极坐标直方图，更具一维极坐标直方图选择机器人运动的合适的方向  </p><pre><code>（1）初始化：根据障碍物向量信息建立向量场直方图。确定开始位置和结束位置。设定角分辨率f=5°，阀值为150，机器人和障碍物的距离/角度的目标方向。（2）Repeat机器人没有到达终点     a.获取机器人360度范围视野内的障碍物分布图，计算极坐标障碍物密度。    b.计算出目标向量kt，    c.推算出最佳前进方向。    d.更新机器人下一坐标robot    Until St是终止状态（3）获得推算出来的路径</code></pre><h2 id="人工势场算法"><a href="#人工势场算法" class="headerlink" title="人工势场算法"></a>人工势场算法</h2><ol><li><p>简介 人工势场法起源于物理学中的势场，是Khatib在1986年提出。它的基本思想是障碍物产生一个斥力势场，障碍物对机器人产生斥力，避免机器人与之发生碰撞，目标点对物体产生引力，引导物体朝向其运动。机器人在引力和斥力的合力作用下驶向目标点。人工势场法中的一个核心问题是关于势场函数的设计。 </p></li><li><p>基本思想 人工势场法具体实现方法为：首先在移动机器人运行环境空间中构建一个人工虚拟势场，该势场由两部分组成，由目标点对移动机器人产生的引力场，方向由机器人指向目标点；由障碍物对移动机器人产生的斥力场，方向为由障碍物指向机器人。运行空间的总势场为斥力场和引力场共同叠加作用。从而通过引力和斥力的合力来控制移动机器人的移动。</p><h2 id="基于行为的编队算法"><a href="#基于行为的编队算法" class="headerlink" title="基于行为的编队算法"></a>基于行为的编队算法</h2></li><li><p>简介<br>基于行为的编队算法的控制策略展现出的智能、可靠、灵活等特点，研究了航天器编队位置和姿态多行为的控制问题。其研究建立了智能封锁雷自由运动模型、向预定地点运动模型、保持队形模型和异常情况处理模型。<br> 基于行为的编队算法，主要表现再智能体编队可以很好的实现分布式控制而且可以完成多种动作，有比较好的时效性，由器当出现多个竞争性目标时，通过行为抑制可以形成较为简单的控制策略。</p></li><li><p>基本思想<br>基于行为的编队控制思想是通过涉及各个智能体的局部动作，控制动作可以例如避障、队形改变、目标检测等等。当外部环境发生变化时，智能体接受外部的信息，经过控制器控制输入作用，使得智能体再运动方向和运动速度发生相应的变化，以实现相适应与环境变化的编队变化。<br>行为控制理论包括3种方法，矢量累加法、行为抑制法和模糊逻辑法。</p><h2 id="领导者的编队算法"><a href="#领导者的编队算法" class="headerlink" title="领导者的编队算法"></a>领导者的编队算法</h2></li><li><p> 概念<br>跟随领导者法的基本思想是在机器人群体中设定一个为领导者，其余设定为跟随者，跟随者以一定的相对距离和相对角度跟随领导者运动，从而保持指定的队形。跟随领导者编队控制方法的优点是所需的信息量相对较少，只需指定领导者的行为和运动轨迹即可，而且控制策略比较灵活。但该方法中由于没有明确的队形反馈，所以如果要获取每个跟随机器人的运动状态，需要进行逐个通讯，这将造成极大的通讯开销。若领导者的前进速度很快或者不能很好的进行避障有可能造成队形的崩溃，另一个缺点是如果领导者失效，将无法保持队形，即鲁棒性较低。</p></li><li><p> 基本思想<br>跟随领导者法又分为队形控制和队形控制。控制是通过领导者和两个跟随者之间的距离l来进行队形的控制；控制是指通过控制领导者和跟随者相对角度和距离来进行队形控制。跟随领导者法是将整个系统的全局编队问题。划分为局部领导者和跟随者之间的问题，领导者的运动轨迹决定整个队形的运动轨迹</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> little_thing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言</title>
      <link href="/2021/07/27/little_thing/c_language/"/>
      <url>/2021/07/27/little_thing/c_language/</url>
      
        <content type="html"><![CDATA[<h1 id="int64"><a href="#int64" class="headerlink" title="__int64"></a>__int64</h1><p>scanf(“%I64d”, &amp;x);<br>printf(“%I64d”, x);</p><h1 id="unsigned-int64"><a href="#unsigned-int64" class="headerlink" title="unsigned __int64"></a>unsigned __int64</h1><p>scanf(“%I64u”, &amp;x);<br>printf(“%I64u”, x);</p><h1 id="gets-and-scanf"><a href="#gets-and-scanf" class="headerlink" title="gets and scanf"></a>gets and scanf</h1><p>gets可以接收空格；而scanf遇到空格、回车和Tab键都会认为输入结束，所有它不能接收空格。<br>所以在输入的字符串中包含空格时，应该使用gets输入。<br>scanf ：当遇到回车，空格和tab键会自动在字符串后面添加’\0’，但是回车，空格和tab键仍会留在输入的缓冲区中。<br>gets：可接受回车键之前输入的所有字符，并用’\n’替代 ‘\0’.回车键不会留在输入缓冲区中<br>gets()用到读取字符串，用回车结束输入<br>scanf()可以读取所有类型的变量  </p>]]></content>
      
      
      <categories>
          
          <category> little_thing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/2021/07/27/little_thing/markdown/"/>
      <url>/2021/07/27/little_thing/markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>1-6个#或 ===或 -</p><h1 id="字体-或"><a href="#字体-或" class="headerlink" title="字体 *或_"></a>字体 *或_</h1><p><em>1个代表斜体</em><br><strong>2个粗体</strong><br><em><strong>3个粗斜体</strong></em>  </p><h1 id="线"><a href="#线" class="headerlink" title="线"></a>线</h1><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格</p><hr><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可<br><del>哈哈哈哈哈</del>  </p><h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><pre><code>创建脚注格式类似这样 [^ AAA]。[^AAA]: 脚注  </code></pre><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格  </p><ul><li>第一项</li><li>第二项</li><li>第三项  <h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2>有序列表使用数字并加上 . 号来表示，如：</li></ul><ol><li>第一项</li><li>第二项</li><li>第三项  <h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2></li></ol><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素  <h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><h2 id="区块-1"><a href="#区块-1" class="headerlink" title="区块"></a>区块</h2>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：<blockquote><p>区块<br>qukuai   </p></blockquote><h2 id="嵌套区块"><a href="#嵌套区块" class="headerlink" title="嵌套区块"></a>嵌套区块</h2><blockquote><p>第一个</p><blockquote><p>第二个</p></blockquote></blockquote></li></ul></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（在1旁边那个键），例如：<br><code>printf()</code>  函数</p><p>  <code> //三个反引号来包含代码区块</code></p><p>tab键或四个空格</p><pre><code>//四个空格</code></pre><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>[名字] (地址)<br>例子<br><a href="https://www.cnblogs.com/sellun/">我的博客</a><br>&lt;地址 &gt;<br><a href="https://www.cnblogs.com/sellun/">https://www.cnblogs.com/sellun/</a></p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>! [alt 属性文本 ]  (<a href="https://pic.cnblogs.com/avatar/2426787/20210619101310.png">https://pic.cnblogs.com/avatar/2426787/20210619101310.png</a>)<br>! [alt 属性文本  ]  (<a href="https://pic.cnblogs.com/avatar/2426787/20210619101310.png">https://pic.cnblogs.com/avatar/2426787/20210619101310.png</a>  “可选标题”)<br>&lt; img src=”<a href="https://pic.cnblogs.com/avatar/2426787/20210619101310.png&quot;">https://pic.cnblogs.com/avatar/2426787/20210619101310.png&quot;</a> width=”50%”&gt;</p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>我们可以设置表格的对齐方式：</p><p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。<br>实例如下：</p><pre><code>| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h1 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h1><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p>]]></content>
      
      
      <categories>
          
          <category> little_thing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>别人的博客</title>
      <link href="/2021/07/27/little_thing/other_blog/"/>
      <url>/2021/07/27/little_thing/other_blog/</url>
      
        <content type="html"><![CDATA[<p>呃呃呃，学了一下git，后面发现廖雪峰的更好<br><a href="https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ">狂神说Git</a><br>实验室的电脑真是令人难受，我怀疑这是阉割版的还未激活的win10，好多服务感觉都莫得，打算用上面的linux系统了都，打开一看，发现要密码，然后问别人也不晓得密码，而且用访客登上去看磁盘空间分配的也好小，我还是老老实实的下这个ssh吧。<br><a href="https://blog.csdn.net/weixin_41601114/article/details/108052922">win10安装ssh服务</a><br><a href="https://zhuanlan.zhihu.com/p/266578775">计算机组成原理</a><br><a href="https://blog.csdn.net/qq_31214779/article/details/107196488#t36">计算机组成原理大概版</a><br><a href="https://www.cnblogs.com/FlyerBird/p/10251925.html">操作系统1</a><br><a href="http://jennica.space/2017/03/21/os-principle/">操作系统面经</a><br><a href="https://lazydog036.gitee.io/2020/10/29/JAVA%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">java集合框架详解</a></p>]]></content>
      
      
      <categories>
          
          <category> little_thing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——0.概述</title>
      <link href="/2021/07/26/networks/0/"/>
      <url>/2021/07/26/networks/0/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络的定义及其特点"><a href="#计算机网络的定义及其特点" class="headerlink" title="计算机网络的定义及其特点"></a>计算机网络的定义及其特点</h1><h2 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h2><p>三大网络：电信网络 有线电视网络 计算机网络（三网融合）   </p><p>发展最快的并起到核心作用的是计算机网络。  </p><p><code>计算机网络定义：</code>计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><h2 id="计算机网络的特点"><a href="#计算机网络的特点" class="headerlink" title="计算机网络的特点"></a>计算机网络的特点</h2><p>连通性   共享</p><h1 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h1><h2 id="互联网概念"><a href="#互联网概念" class="headerlink" title="互联网概念"></a>互联网概念</h2><p><code>定义：</code>互联网，特指 Internet，它起源于美国，是由数量极大的各种计算机网络互连起来而形成的一个互连网络。它采用 TCP/IP 协议族作为通信规则，是一个覆盖全球、实现全球范围内连通性和资源共享的计算机网络。  </p><p>以小写字母 “i” 开始的 internet（互连网）是一个通用名词，它泛指由多个计算机网络互连而成的网络。   </p><p>以大写字母 “I” 开始的的 Internet（互联网或因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的 ARPANET。</p><h2 id="互联网基础结构发展的三个阶段"><a href="#互联网基础结构发展的三个阶段" class="headerlink" title="互联网基础结构发展的三个阶段"></a>互联网基础结构发展的三个阶段</h2><ol><li>从单个网络 ARPANET 向互联网发展的过程。 <ul><li>1983 年，TCP/IP 协议成为 ARPANET 上的标准协议，使得所有使用 TCP/IP 协议的计算机都能利用互连网相互通信。</li><li>人们把 1983 年作为互联网的诞生时间。</li><li>1990年，ARPANET 正式宣布关闭。</li></ul></li><li>建成了三级结构的互联网。 <ul><li>它是一个三级计算机网络，分为主干网、地区网和校园网（或企业网）。</li></ul></li><li>逐渐形成了多层次 ISP 结构的互联网。 <ul><li>出现了互联网服务提供者 ISP (Internet Service Provider)。</li><li>任何机构和个人只要向某个 ISP 交纳规定的费用，就可从该 ISP 获取所需 IP 地址的使用权，并可通过该 ISP 接入到互联网。</li><li>根据提供服务的覆盖面积大小以及所拥有的IP地址数目的不同，ISP 也分成为不同层次的 ISP：主干 ISP、地区 ISP和本地 ISP。</li></ul></li></ol><h2 id="互联网的标准化工作"><a href="#互联网的标准化工作" class="headerlink" title="互联网的标准化工作"></a>互联网的标准化工作</h2><p>所有互联网标准都以 RFC 的形式在互联网上发表。</p><h1 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h1><h2 id="互联网的边缘部分"><a href="#互联网的边缘部分" class="headerlink" title="互联网的边缘部分"></a>互联网的边缘部分</h2><p>由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。    </p><p>c/s模式 p2p模式  </p><h2 id="互联网的核心部分"><a href="#互联网的核心部分" class="headerlink" title="互联网的核心部分"></a>互联网的核心部分</h2><p>由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。<br><code>路由器分组转发</code>是网络核心部分最重要的功能。互联网的核心部分采用了分组交换技术<br>典型交换技术包括：  </p><pre><code>电路交换  ：建立连接，通信，释放连接（面向连接的）分组交换  ：存储转发报文交换  : 用的少</code></pre><h1 id="计算机网络在我国的发展"><a href="#计算机网络在我国的发展" class="headerlink" title="计算机网络在我国的发展"></a>计算机网络在我国的发展</h1><ul><li>1980 年，铁道部开始进行计算机联网实验。</li><li>1989 年 11 月，我国第一个公用分组交换网 CNPAC 建成运行。 </li><li>1994 年 4 月 20 日，我国用 64 kbit/s 专线正式连入互联网，我国被国际上正式承认为接入互联网的国家。</li><li>1994 年 5 月，中国科学院高能物理研究所设立了我国的第一个万维网服务器。</li><li>1994 年 9 月，中国公用计算机互联网 CHINANET 正式启动。</li></ul><h1 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h1><ol><li><p>按照网络的作用范围进行分类</p><ul><li>广域网 WAN (Wide Area Network)：作用范围通常为几十到几千公里。</li><li>城域网 MAN (Metropolitan Area Network)：作用距离约为 5~50 公里。</li><li>局域网 LAN (Local Area Network) ：局限在较小的范围（如 1 公里左右）。</li><li>个人区域网 PAN (Personal Area Network) ：范围很小，大约在 10 米左右。</li><li>若中央处理机之间的距离非常近（如仅 1 米的数量级甚至更小些），则一般就称之为多处理机系统，而不称它为计算机网络</li></ul></li><li><p>按照网络的使用者进行分类</p><ul><li>公用网 (public network)<br>按规定交纳费用的人都可以使用的网络。因此也可称为公众网。</li><li>专用网 (private network)<br>为特殊业务工作的需要而建造的网络。</li></ul></li><li><p>用来把用户接入到互联网的网络  </p><ul><li>接入网 AN (Access Network)，它又称为本地接入网或居民接入网。</li><li>接入网是一类比较特殊的计算机网络，用于将用户接入互联网。</li><li>接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。</li><li>接入网是从某个用户端系统到互联网中的第一个路由器（也称为边缘路由器）之间的一种网络。</li><li>从覆盖的范围看，很多接入网还是属于局域网。</li><li>从作用上看，接入网只是起到让用户能够与互联网连接的“桥梁”作用<h1 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h1><h2 id="性能特征"><a href="#性能特征" class="headerlink" title="性能特征"></a>性能特征</h2><code>速率: </code>往往是指额定速率或标称速率，非实际运行速率。<br><code>带宽: </code>在单位时间内网络中的某信道所能通过的“最高数据率”。单位是 bit/s<br><code>吞吐量： </code>在单位时间内通过某个网络（或信道、接口）的数据量。更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。<br><code>时延： </code>数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。<br>时延=发送时延+传播时延+处理时延+排队时延<br><code>时延带宽积： </code>时延带宽积 = 传播时延 × 带宽<br><code>往返时延（RTT）： </code>双向交互一次所需的时间<br>对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率。<br><code>利用率： </code>信道利用率指出某信道有百分之几的时间是被利用的；网络利用率则是全网络的信道利用率的加权平均值。信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。   </li></ul></li></ol><p> D0 表示网络空闲时的时延，D 表示网络当前的时延,U代表网络利用率</p><pre><code>D=D0/(1-U)</code></pre><h2 id="非性能特征"><a href="#非性能特征" class="headerlink" title="非性能特征"></a>非性能特征</h2><p>费用<br>质量<br>标准化<br>可靠性<br>可扩展性和可升级性<br>易于管理和维护 </p><h1 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><code>协议： </code>为进行网络中的数据交换而建立的规则、标准或约定。（文字描述或代码描述）   </p><p>三大要素：</p><ul><li>语法：数据与控制信息的结构或格式 。 </li><li>语义：需要发出何种控制信息，完成何种动作以及做 出何种响应。 </li><li>同步：事件实现顺序的详细说明。 </li></ul><h2 id="分层优点"><a href="#分层优点" class="headerlink" title="分层优点"></a>分层优点</h2><ul><li>各层之间是独立的。</li><li>灵活性好。</li><li>结构上可分割开。</li><li>易于实现和维护。</li><li>能促进标准化工作。<h2 id="分层缺点"><a href="#分层缺点" class="headerlink" title="分层缺点"></a>分层缺点</h2></li><li>降低效率。</li><li>有些功能会在不同的层次中重复出现，因而产生了额外开销。<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B.png" alt="层次结构模型"></li></ul><p>协议是“水平的”，即协议是控制对等实体之间通信的规则。<br>服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。<br>现在的互联网使用的 TCP/IP 体系结构有时已经发生了演变，即某些应用程序可以直接使用 IP 层，或甚至直接使用最下面的网络接口层。</p>]]></content>
      
      
      <categories>
          
          <category> networks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——1.物理层</title>
      <link href="/2021/07/26/networks/1/"/>
      <url>/2021/07/26/networks/1/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。<br>物理层的作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异。<br>主要任务：确定与传输媒体的接口的一些特性。</p><ul><li>机械特性 ：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。</li><li>电气特性：指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性：指明某条线上出现的某一电平的电压的意义。</li><li>过程特性 ：指明对于不同功能的各种可能事件的出现顺序。 </li></ul><h1 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h1><h2 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h2><p>一个数据通信系统包括三大部分：源系统（或发送端、发送方）、传输系统（或传输网络）和目的系统（或接收端、接收方）。 </p><h2 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h2><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><p>调频，调幅，调相  </p><p>不是码元越多越好。若每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难，出错率增加。  </p><p>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。  </p><ul><li>基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (coding)。</li><li>带通调制：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。<br>带通信号 ：经过载波调制后的信号。<h3 id="常用编码方式"><a href="#常用编码方式" class="headerlink" title="常用编码方式"></a>常用编码方式</h3></li><li>不归零制：正电平代表 1，负电平代表 0。</li><li>归零制：正脉冲代表 1，负脉冲代表 0。</li><li>曼彻斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。</li><li>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。  </li></ul><p>从信号波形中可以看出，曼彻斯特 (Manchester) 编码和差分曼彻斯特编码产生的信号频率比不归零制高。<br>从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率（这叫做没有自同步能力），而曼彻斯特编码和差分曼彻斯特编码具有自同步能力。</p><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p>限制码元在信道上的传输速率的因素有以下两个：</p><ul><li>信道能够通过的频率范围</li><li>信噪比</li></ul><p><code>奈氏准则:</code>给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。</p><p>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。    如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。  </p><p><code>信噪比</code>就是信号的平均功率和噪声的平均功率之比。常记为S/N，并用分贝 (dB) 作为度量单位。即：   </p><p><code>信噪比(dB) = 10 log10(S/N ) (dB)  </code></p><p><code>香农公式</code><br>极限信息传输速率 C ;W 为信道的带宽（以 Hz 为单位）；S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率。<br><code>C = W log2(1+S/N)    (bit/s) </code>  </p><p>香农公式表明</p><ul><li>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 </li><li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 </li><li>若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。</li><li>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。 </li></ul><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><p>双绞线<br>同轴电缆:具有很好的抗干扰特性，被广泛用于传输较高速率的数据。(50 Ω 同轴电缆 —— LAN / 数字传输常用;~~~75 Ω 同轴电缆 —— 有线电视 / 模拟传输常用)<br>光缆： 多模光纤 ，单模光纤<br>光纤通信优点</p><ol><li>通信容量非常大。</li><li>传输损耗小，中继距离长。</li><li>抗雷电和电磁干扰性能好。</li><li>无串音干扰，保密性好。</li><li>体积小，重量轻。</li></ol><h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><ul><li>将自由空间称为“非导引型传输媒体”。</li><li>无线传输所使用的频段很广。</li><li>短波通信（即高频通信）主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低。</li><li>微波在空间主要是直线传播。</li><li>传统微波通信有两种方式： 1.地面微波接力通信2.卫星通信 </li></ul><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><p> 频分复用 FDM、时分复用 TDM、统计时分复用 STDM、波分复用 WDM、码分复用　CDM<br> 复用 (multiplexing) 是通信技术中的基本概念。<br>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。　　　　</p><p><code>掌握码分复用的习题</code></p><h1 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h1><p>标准和同步问题</p><p>在早期电话网中，从市话局到用户电话机的用户线是采用最廉价的双绞线电缆，而长途干线采用的是频分复用 FDM 的模拟传输方式。<br>与模拟通信相比，数字通信无论是在传输质量上还是经济上都有明显的优势。<br>目前，长途干线大都采用时分复用 PCM 的数字传输方式。<br>脉码调制 PCM 体制最初是为了在电话局之间的中继线上传送多路的电话。</p><h1 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h1><h2 id="ADSL-技术"><a href="#ADSL-技术" class="headerlink" title="ADSL 技术"></a>ADSL 技术</h2><p>从宽带接入的媒体来看，可以划分为两大类：有线宽带接入，无线宽带接入<br>非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line) 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。ADSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。</p><h2 id="光纤同轴混合网（HFC网）"><a href="#光纤同轴混合网（HFC网）" class="headerlink" title="光纤同轴混合网（HFC网）"></a>光纤同轴混合网（HFC网）</h2><ul><li>HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。</li><li>在模拟光纤中采用光的振幅调制AM，这比使用数字光纤更为经济。</li><li>模拟光纤从头端连接到光纤结点 (fiber node)，即光分配结点 ODN (Optical Distribution Node)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆。 </li></ul><h2 id="FTTx-技术"><a href="#FTTx-技术" class="headerlink" title="FTTx 技术"></a>FTTx 技术</h2><p>FTTx 是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。<br>FTTx 表示 Fiber To The…（光纤到…），例如：</p><ul><li>光纤到户 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭，可能是居民接入网最后的解决方法。</li><li>光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</li><li>光纤到路边 FTTC (Fiber To The Curb)：光纤铺到路边，从路边到各用户可使用星形结构双绞线作为传输媒体。</li></ul>]]></content>
      
      
      <categories>
          
          <category> networks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——2.链路层</title>
      <link href="/2021/07/26/networks/2/"/>
      <url>/2021/07/26/networks/2/</url>
      
        <content type="html"><![CDATA[<p>不同的链路层可能采用不同的数据链路层协议<br>数据链路层使用的信道  </p><ol><li>点对点信道:这种信道使用一对一的点对点通信方式。</li><li>广播信道:使用一对多的广播通信方式。因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li></ol><h1 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h1><h2 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h2><p><code>链路 (物理链路)</code> (link) 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分<br><code>数据链路 (逻辑链路)</code>(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。  </p><p>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。<br>一般的适配器都包括了数据链路层和物理层这两层的功能。 </p><h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><p><code>封装成帧:</code>控制字符 SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT (End Of Transmission) 表示帧的结束。  </p><p><code>透明传输:</code>字节填充或字符填充.发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B)。接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。<br>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。<br>透明:指某一个实际存在的事物看起来却好像不存在一样.在数据链路层透明传送数据”表示无论发送什么样的比特组合的数据，这些数据都能够按照原样没有差错地通过这个数据链路层</p><p><code>差错控制:</code> 在数据链路层传送的帧中，广泛使用了<code>循环冗余检验 CRC </code>的检错技术。传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)误码率与信噪比有很大的关系。为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。</p><p>数据后面添加上的冗余码称为<code>帧检验序列 FCS</code> (Frame Check Sequence)。  </p><p>仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受 (accept)<br>单纯使用 CRC 差错检测技术不能实现“无差错传输”或“可靠传输”。“无比特差错”与“无传输差错”是不同的概念,在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。要做到“无差错传输”（即发送什么就收到什么）就必须再加上确认和重传机制。</p><h1 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h1><h2 id="PPP-协议的特点"><a href="#PPP-协议的特点" class="headerlink" title="PPP 协议的特点"></a>PPP 协议的特点</h2><p>对于点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>简单 —— 这是首要的要求。</li><li>封装成帧 —— 必须规定特殊的字符作为帧定界符。</li><li>透明性 —— 必须保证数据传输的透明性。</li><li>多种网络层协议 —— 能够在同一条物理链路上同时支持多种网络层协议。</li><li>多种类型链路 —— 能够在多种类型的链路上运行。</li><li>差错检测 —— 能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</li><li>检测连接状态 —— 能够及时自动检测出链路是否处于正常工作状态。</li><li>最大传送单元 —— 必须对每一种类型的点对点链路设置最大传送单元  MTU 的标准默认值，促进各种实现之间的互操作性。</li><li>网络层地址协商 —— 必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。</li><li>数据压缩协商 —— 必须提供一种方法来协商使用数据压缩算法。</li></ul><h3 id="PPP-协议不需要的功能"><a href="#PPP-协议不需要的功能" class="headerlink" title="PPP 协议不需要的功能"></a>PPP 协议不需要的功能</h3><p>纠错<br>流量控制<br>序号<br>多点线路<br>半双工或单工链路 </p><h3 id="PPP-协议的组成"><a href="#PPP-协议的组成" class="headerlink" title="PPP 协议的组成"></a>PPP 协议的组成</h3><ol><li>一个将 IP 数据报封装到串行链路的方法。</li><li>链路控制协议 LCP (Link Control Protocol)。</li><li>网络控制协议 NCP (Network Control Protocol)。 </li></ol><h2 id="PPP-协议的帧格式"><a href="#PPP-协议的帧格式" class="headerlink" title="PPP 协议的帧格式"></a>PPP 协议的帧格式</h2><p>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/ppp%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="ppp帧格式"></p><h3 id="透明传输问题"><a href="#透明传输问题" class="headerlink" title="透明传输问题"></a>透明传输问题</h3><p>当 PPP 用在异步传输时，就使用一种特殊的字符填充法。<br>当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充</p><h4 id="字符填充"><a href="#字符填充" class="headerlink" title="字符填充"></a>字符填充</h4><p> 0x7E-&gt;(0x7D, 0x5E)<br> 0x7D-&gt;(0x7D, 0x5D)<br>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。 </p><h4 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h4><p> 5 个连续 1，则立即填入一个 0</p><h3 id="不提供使用序号和确认的可靠传输"><a href="#不提供使用序号和确认的可靠传输" class="headerlink" title="不提供使用序号和确认的可靠传输"></a>不提供使用序号和确认的可靠传输</h3><ol><li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li><li>在因特网环境下，PPP 的信息字段放入的数据是 IP  数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li><li>帧检验序列 FCS 字段可保证无差错接受。<h2 id="PPP-协议的工作状态"><a href="#PPP-协议的工作状态" class="headerlink" title="PPP 协议的工作状态"></a>PPP 协议的工作状态</h2>PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/ppp%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="ppp协议状态图"><h1 id="用广播信道的数据链路层"><a href="#用广播信道的数据链路层" class="headerlink" title="用广播信道的数据链路层"></a>用广播信道的数据链路层</h1><h2 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h2><h3 id="局域网特点"><a href="#局域网特点" class="headerlink" title="局域网特点"></a>局域网特点</h3></li><li>网络为一个单位所拥有；</li><li>地理范围和站点数目均有限；<h3 id="局域网优点"><a href="#局域网优点" class="headerlink" title="局域网优点"></a>局域网优点</h3></li><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。<h3 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h3>星形网，总线网，环形网<h3 id="媒体共享技术"><a href="#媒体共享技术" class="headerlink" title="媒体共享技术"></a>媒体共享技术</h3>静态划分信道：频分复用，时分复用，波分复用，码分复用<br>动态媒体接入控制（多点接入）：随机接入和控接入 ，如多点线路探询 (polling)，或轮询。<h3 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a>以太网的两个标准</h3>DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约。<br>IEEE 802.3 是第一个 IEEE 的以太网标准。<br>DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别，因此可以将 802.3 局域网简称为“以太网”。<br>严格说来，“以太网”应当是指符合 DIX Ethernet V2 标准的局域网 。 <h3 id="数据链路层的两个子层"><a href="#数据链路层的两个子层" class="headerlink" title="数据链路层的两个子层"></a>数据链路层的两个子层</h3>逻辑链路控制 LLC (Logical Link Control)子层；<br>媒体接入控制 MAC (Medium Access Control)子层；<br>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成两个子层<br>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。<br>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。LLC 子层看不见下面的局域网</li></ol><p>现在一般不考虑 LLC 子层，很多厂商生产的适配器上就仅装有 MAC 协议而没有 LLC 协议。 </p><h3 id="适配器（网卡）"><a href="#适配器（网卡）" class="headerlink" title="适配器（网卡）"></a>适配器（网卡）</h3><p>作用：</p><ol><li>进行串行/并行转换。</li><li>对数据进行缓存。</li><li>在计算机的操作系统安装设备驱动程序。</li><li>实现以太网协议。<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/%E7%BD%91%E5%8D%A1.png" alt="网卡作用"></li></ol><h3 id="以太网采取的两种重要的措施"><a href="#以太网采取的两种重要的措施" class="headerlink" title="以太网采取的两种重要的措施"></a>以太网采取的两种重要的措施</h3><ol><li>采用较为灵活的无连接的工作方式   <ul><li>不必先建立连接就可以直接发送数据。</li><li>对发送的数据帧不进行编号，也不要求对方发回确认。<br>这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的。</li><li>以太网提供的服务是不可靠的交付，即尽最大努力的交付。</li><li>当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。</li><li>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</li></ul></li><li>以太网发送的数据都使用曼彻斯特 (Manchester) 编码<br>曼彻斯特编码缺点是：它所占的频带宽度比原始的基带信号增加了一倍。</li></ol><h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h2><p>CSMA/CD 含义：载波监听多点接入 / 碰撞检测  (Carrier Sense Multiple Access with Collision Detection) 。<br>CSMA/CD 协议工作流程<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/CSMACD%20%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="CSMA/CD 协议工作流程"></p><h3 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h3><ul><li>最先发送数据帧的站，在发送数据帧后至多经过时间 2 （两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。</li><li>以太网的端到端往返时延 2  称为争用期，或碰撞窗口。</li><li>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。<h3 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h3>发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</li></ul><ol><li>基本退避时间取为争用期 2  。</li><li>从整数集合 [0, 1, … , (2k - 1)] 中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。</li><li>参数 k 按下面的公式计算：<br>k = Min[重传次数, 10]</li><li>当 k ≤10 时，参数 k 等于重传次数。</li><li>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。  <h3 id="10-Mbit-s-以太网争用期的长度"><a href="#10-Mbit-s-以太网争用期的长度" class="headerlink" title="10 Mbit/s 以太网争用期的长度"></a>10 Mbit/s 以太网争用期的长度</h3></li></ol><ul><li>10 Mbit/s 以太网取 51.2 s 为争用期的长度。</li><li>对于 10 Mbit/s 以太网，在争用期内可发送 512 bit，即 64 字节。  </li></ul><p>这意味着：<br>以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突。</p><p>以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</p><p>在 10 Mbit/s 以太网 51.2 μs 的争用期内，信号能传输多远的距离？<br>以太网上最大的端到端单程时延必须小于争用期的一半（即 25.6 μs），这相当于以太网的最大端到端长度约为 5 km。</p><ul><li>使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。</li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 </li><li>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/csma.png" alt="csma"><h2 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h2></li><li>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</li><li>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器 (hub)。  </li></ul><p>传统以太网使用同轴电缆，采用总线形拓扑结构</p><h3 id="星形以太网-10BASE-T"><a href="#星形以太网-10BASE-T" class="headerlink" title="星形以太网 10BASE-T"></a>星形以太网 10BASE-T</h3><ul><li>使用无屏蔽双绞线，采用星形拓扑。</li><li>每个站需要用两对双绞线，分别用于发送和接收。</li><li>双绞线的两端使用 RJ-45 插头。</li><li>集线器使用了大规模集成电路芯片，因此集线器的可靠性提高。 </li><li>10BASE-T 的通信距离稍短，每个站到集线器的距离不超过 100m。</li></ul><p>这种 10 Mbit/s 速率的无屏蔽双绞线星形网的出现，既降低了成本，又提高了可靠性。 具有很高的性价比。<br>从此以太网的拓扑就从总线形变为更加方便的星形网络，而以太网也就在局域网中占据了统治地位。</p><h3 id="集线器特点"><a href="#集线器特点" class="headerlink" title="集线器特点"></a>集线器特点</h3><ul><li>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。 </li><li>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。 </li><li>集线器很像一个多接口的转发器，工作在物理层。</li><li>集线器采用了专门的芯片，进行自适应串音回波抵消，减少了近端串音。</li></ul><h2 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h2><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png" alt="信道利用率"></p><h2 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h2><ol><li>MAC 层的硬件地址<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/mac%E5%B1%82%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80.png" alt="MAC 层的硬件地址"><br>生产适配器时，6 字节的 MAC 地址已被固化在适配器的 ROM，因此，MAC 地址也叫做硬件地址 (hardware address) 或物理地址。</li><li>MAC 帧的格式<br>常用的以太网 MAC 帧格式有两种标准：<br>DIX Ethernet V2 标准<br>IEEE 的 802.3 标准<br>最常用的 MAC 帧是以太网 V2 的格式。<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/%E4%BB%A5%E5%A4%AA%E7%BD%91%20V2%20%E7%9A%84%20MAC%20%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="以太网V2的MAC帧格式">    </li></ol><p>无效的 MAC 帧</p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间</li></ul><p>帧间最小间隔</p><ul><li>帧间最小间隔为 9.6 us，相当于 96 bit 的发送时间。</li><li>一个站在检测到总线开始空闲后，还要等待 9.6 us 才能再次发送数据。</li><li>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。 </li></ul><h1 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h1><h2 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h2><ul><li>使用光纤扩展   <ol><li>主机使用光纤（通常是一对光纤）和一对光纤调制解调器连接到集线器。 </li><li>很容易使主机和几公里以外的集线器相连接。</li></ol></li><li>使用集线器扩展   <ol><li>将多个以太网段连成更大的、多级星形结构的以太网。</li><li><code>优点</code>:使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。扩大了以太网覆盖的地理范围。</li><li><code>缺点</code>:碰撞域增大了，但总的吞吐量并未提高。如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。 <h2 id="网桥与以太网交换机"><a href="#网桥与以太网交换机" class="headerlink" title="网桥与以太网交换机"></a>网桥与以太网交换机</h2>网桥</li></ol></li><li>网桥工作在数据链路层。</li><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。   </li></ul><p>以太网交换机</p><ul><li>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。</li><li>交换式集线器常称为以太网交换机 (switch) 或第二层交换机 (L2 switch)，强调这种交换机工作在数据链路层。</li><li>以太网交换机实质上就是一个多接口的网桥。</li><li>每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。</li><li>以太网交换机具有并行性。</li></ul><h2 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h2><p>以太网交换机的每个接口是一个碰撞域<br>以太网交换机的接口有存储器，能在输出端口繁忙时把到来的帧进行缓存。<br>以太网交换机是一种即插即用设备，其内部的帧交换表（又称为地址表）是通过<code>自学习算法</code>自动地逐渐建立起来的。<br>以太网交换机使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。<br>以太网交换机的性能远远超过普通的集线器，而且价格并不贵。</p><p>以太网交换机的交换方式<br>存储转发方式<br>直通 (cut-through) 方式(提高了帧的转发速度。它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。)</p><h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。<br>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。<br>虚拟局域网（VLAN）技术具有以下主要优点：    </p><ul><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ul><p>划分虚拟局域网的方法:</p><ul><li>基于交换机端口</li><li>基于计算机网卡的MAC地址</li><li>基于协议类型</li><li>基于IP子网地址</li><li>基于高层应用或服务</li></ul><h1 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h1><p>吉比特以太网工作在半双工方式时，就必须进行碰撞检测。<br>为保持 64 字节最小帧长度，以及 100 米的网段的最大长度，吉比特以太网增加了两个功能：</p><ul><li><p>载波延伸 (carrier extension)<br>使最短帧长仍为 64 字节（这样可以保持兼容性），同时将争用时间增大为 512 字节。<br>凡发送的 MAC 帧长不足 512 字节时，就用一些特殊字符填充在帧的后面，使MAC 帧的发送长度增大到 512 字节。接收端在收到以太网的 MAC 帧<br>后，要将所填充的特殊字符删除后才向高层交付。</p></li><li><p>分组突发 (packet bursting)<br>当很多短帧要发送时，第一个短帧要采用载波延伸方法进行填充，随后的一些短帧则可一个接一个地发送，只需留有必要的帧间最小间隔即可。这样就形成可一串分组的突发，直到达到 1500 字节或稍多一些为止</p></li></ul><p>吉比特以太网工作在全双工方式时（即通信双方可同时进行发送和接收数据），不使用载波延伸和分组突发</p>]]></content>
      
      
      <categories>
          
          <category> networks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——3.网络层</title>
      <link href="/2021/07/26/networks/3/"/>
      <url>/2021/07/26/networks/3/</url>
      
        <content type="html"><![CDATA[<h1 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h1><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/ip_tow_method.png" alt="ip层两种服务"></p><h1 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h1><p>与 IP 协议配套使用的还有三个协议：   </p><ul><li>地址解析协议 ARP (Address Resolution Protocol)</li><li>网际控制报文协议 ICMP (Internet Control Message Protocol)</li><li>网际组管理协议 IGMP (Internet Group Management Protocol)<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/ip%E5%B1%82%E9%85%8D%E5%A5%97%E5%8D%8F%E8%AE%AE.png" alt="IP层配套协议"><h2 id="虚拟互连网络"><a href="#虚拟互连网络" class="headerlink" title="虚拟互连网络"></a>虚拟互连网络</h2>将网络互相连接起来要使用一些中间设备。<br>中间设备又称为中间系统或中继 (relay)系统。<br>有以下五种不同的中间设备：   </li><li>物理层中继系统：转发器 (repeater)。</li><li>数据链路层中继系统：网桥 或 桥接器 (bridge)。</li><li>网络层中继系统：路由器 (router)。</li><li>网桥和路由器的混合物：桥路器 (brouter)。</li><li>网络层以上的中继系统：网关 (gateway)。 </li></ul><p>当中继系统是转发器或网桥时，一般并不称之为网络互连，因为这仅仅是把一个网络扩大了，而这仍然是一个网络。<br>网关由于比较复杂，目前使用得较少。<br>网络互连都是指用路由器进行网络互连和路由选择。</p><p>虚拟互连网络的意义<br>所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。<br>使用 IP 协议的虚拟互连网络可简称为 IP 网。<br>使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。<br>如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的互联网 (Internet)。   </p><h2 id="分类的-IP-地址"><a href="#分类的-IP-地址" class="headerlink" title="分类的 IP 地址"></a>分类的 IP 地址</h2><p>ip地址==网络号 net-id+主机号 host-id<br>各类ip地址<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/%E5%90%84%E7%B1%BBip%E5%9C%B0%E5%9D%80.png" alt="各类ip地址"><br>三类常用ip地址<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/%E4%B8%89%E7%B1%BB%E5%B8%B8%E7%94%A8ip%E5%9C%B0%E5%9D%80.png" alt="三类常用ip地址1"><br>特殊ip<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/%E7%89%B9%E6%AE%8Aip%E5%9C%B0%E5%9D%80.png" alt="特殊ip">   </p><p>IP 地址的一些重要特点   </p><ol><li>IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。     </li><li>路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li></ol><p>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口。</p><ul><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为多归属主机 (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的 IP 地址。 </li></ul><p>用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。   </p><p>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</p><h2 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h2><p><code>ARP 作用</code>：从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。</p><p>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。<br>每一个主机都设有一个 ARP 高速缓存 (ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。<br>TTL (Time To Live)：地址映射有效时间 。</p><p>  <code> &lt; IP address；MAC address；TTL &gt;</code></p><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/ip%E4%B8%8Emac.png" alt="ip与mac">  </p><p>ARP特点</p><ul><li>ARP请求分组：包含发送方硬件地址 / 发送方 IP 地址 / 目标方硬件地址(未知时填 0) / 目标方 IP 地址。</li><li>本地广播 ARP 请求（路由器不转发ARP请求）。</li><li>ARP 响应分组：包含发送方硬件地址 / 发送方 IP地址 / 目标方硬件地址 / 目标方 IP 地址。</li><li>ARP 分组封装在物理网络的帧中传输。</li></ul><p>ARP作用</p><ul><li>存放最近获得的 IP 地址到 MAC 地址的绑定，以减少 ARP 广播的数量。</li><li>为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。</li><li>当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。 </li></ul><p>应当注意的问题</p><ul><li>ARP 用于解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。</li><li>如果所要找的主机和源主机不在同一个局域网上，那么就要通过ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</li><li>从 IP 地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。</li><li>只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。 </li></ul><p><code>为什么不直接使用硬件地址进行通信</code></p><ul><li>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事。</li><li>IP 编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用 ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。</li><li>因此，在虚拟的 IP 网络上用 IP 地址进行通信给广大的计算机用户带来了很大的方便。</li></ul><h2 id="IP-数据报的格式"><a href="#IP-数据报的格式" class="headerlink" title="IP 数据报的格式"></a>IP 数据报的格式</h2><p>一个 IP 数据报由首部和数据两部分组成。<br>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。<br>在首部的固定部分的后面是一些可选字段，其长度是可变的。<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/ip%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="ip数据包格式"></p><ul><li><code>版本</code> :占 4 位，指 IP 协议的版本。</li><li><code>首部长度</code> :占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。</li><li><code>区分服务</code> :占 8 位，用来获得更好的服务。一般不用，只有在使用区分服务时才用</li><li><code>总长度</code> ：占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元MTU。</li><li><code>标识(identification)</code> ——占 16 位，<br>它是一个计数器，用来产生 IP 数据报的标识。</li><li><code>标志(flag)</code> ——占 3 位，目前只有前两位有意义。<br>标志字段的最低位是 MF (More Fragment)。<br>MF=1 表示后面“还有分片”。MF=0 表示最后一个分片。<br>标志字段中间的一位是 DF (Don’t Fragment) 。<br>只有当 DF=0 时才允许分片。</li><li><code>片偏移</code> ：占13 位，指出：较长的分组在分片后<br>某片在原分组中的相对位置。<br>片偏移以 8 个字节为偏移单位。</li><li><code>生存时间</code> ：占8 位，记为 TTL (Time To Live)，<br>指示数据报在网络中可通过的路由器数的最大值。</li><li><code>协议</code> :占8位，指出此数据报携带的数据使用何种协议，<br>以便目的主机的 IP 层将数据部分上交给那个处理过程</li><li><code>首部检验和</code>  :占16 位，只检验数据报的首部，<br>不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。（求和取反码）  </li><li><code>可变部分</code> :IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。<br>选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。<br>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。<br>实际上这些选项很少被使用。</li></ul><h2 id="IP-层转发分组的流程"><a href="#IP-层转发分组的流程" class="headerlink" title="IP 层转发分组的流程"></a>IP 层转发分组的流程</h2><p>按主机所在的网络地址来制作路由表<br>路由器分组转发算法</p><ol><li>从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。</li><li>若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行 (3)。</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 (4)。</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行 (5)。</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 (6)。</li><li>报告转发分组出错。 </li></ol><h1 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h1><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。这种做法叫做划分子网 (subnetting)   </p><p>在 ARPANET 的早期，IP 地址的设计确实不够合理：<br>(1) IP 地址空间的利用率有时很低。<br>(2) 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。<br>(3) 两级的 IP 地址不够灵活。  </p><p>划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。<br>从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。<br><code>IP地址 ::= &#123;&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;&#125;     </code></p><p>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。<br>然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。<br>最后就将 IP 数据报直接交付目的主机。 </p><p>优点：</p><ol><li>减少了 IP 地址的浪费</li><li>使网络的组织更加灵活</li><li>更便于维护和管理</li></ol><p>划分子网纯属一个单位内部的事情，对外部网络透明，对外仍然表现为没有划分子网的一个网络。</p><p>子网掩码是一个网络或一个子网的重要属性。</p><ul><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul><p>有固定长度子网和变长子网两种子网划分方法。<br>在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的。<br>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。   </p><p>“子网号的位数”中没有 0, 1, 15 和 16 这四种情况，因为这没有意义。</p><h2 id="使用子网时分组的转发"><a href="#使用子网时分组的转发" class="headerlink" title="使用子网时分组的转发"></a>使用子网时分组的转发</h2><p>与IP 层转发分组的流程相似，区别就是多了个与操作</p><h2 id="无分类编址-CIDR（构造超网）"><a href="#无分类编址-CIDR（构造超网）" class="headerlink" title="无分类编址 CIDR（构造超网）"></a>无分类编址 CIDR（构造超网）</h2><p>无分类域间路由选择 CIDR (Classless Inter-Domain Routing)</p><p>CIDR 最主要的特点</p><ul><li>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。</li><li>CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。</li><li>IP 地址从三级编址（使用子网掩码）又回到了两级编址。    </li></ul><p>无分类的两级编址<br><code>IP地址 ::= &#123;&lt;网络前缀&gt;, &lt;主机号&gt;&#125;   </code><br>CIDR 使用“斜线记法”(slash notation)，它又称为 CIDR 记法，即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中 1 的个数）。例如： 220.78.168.0/24<br>CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”。</p><p>路由聚合 (route aggregation)    </p><ul><li>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。</li><li>路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。</li><li>路由聚合也称为构成超网 (supernetting)。</li><li>CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。</li><li>对于 /20  地址块，它的掩码是 20 个连续的 1。 斜线记法中的数字就是掩码中1的个数。 </li></ul><p>构成超网</p><ul><li>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C  类地址。</li><li>这些 C 类地址合起来就构成了超网。</li><li>CIDR 地址块中的地址数一定是 2 的整数次幂。</li><li>网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。</li><li>CIDR 的一个好处是：可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。 </li></ul><p>使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。 应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配 (longest-prefix matching)。<br>网络前缀越长，其地址块就越小，因而路由就越具体 (more specific) 。</p><h1 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h1><h2 id="ICMP-报文的种类"><a href="#ICMP-报文的种类" class="headerlink" title="ICMP 报文的种类"></a>ICMP 报文的种类</h2><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。<br>但 ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议。</p><p>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 </p><p>ICMP 差错报告报文共有 4 种</p><ul><li>终点不可达 </li><li>时间超过 </li><li>参数问题 </li><li>改变路由（重定向）(Redirect) </li></ul><p>不应发送 ICMP 差错报告报文的几种情况</p><ul><li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。</li><li>对具有多播地址的数据报都不发送 ICMP 差错报告报文。<br>对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</li></ul><h2 id="ICMP-的应用举例"><a href="#ICMP-的应用举例" class="headerlink" title="ICMP 的应用举例"></a>ICMP 的应用举例</h2><h3 id="PING-Packet-InterNet-Groper"><a href="#PING-Packet-InterNet-Groper" class="headerlink" title="PING (Packet InterNet Groper)"></a>PING (Packet InterNet Groper)</h3><p>PING 用来测试两个主机之间的连通性。<br>PING 使用了 ICMP 回送请求与回送回答报文。<br>PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。  </p><h3 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h3><p>在 Windows 操作系统中这个命令是 tracert。<br>用来跟踪一个分组从源点到终点的路径。<br>它利用 IP 数据报中的 TTL 字段和 ICMP 时间超过差错报告报文实现对从源点到终点的路径的跟踪。</p><h1 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h1><p>静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。<br>动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。   </p><p>自治系统之间的路由选择也叫做域间路由选择 (interdomain routing)，在自治系统内部的路由选择叫做域内路由选择 (intradomain routing) 。</p><h2 id="内部网关协议-IGP-Interior-Gateway-Protocol"><a href="#内部网关协议-IGP-Interior-Gateway-Protocol" class="headerlink" title="内部网关协议 IGP (Interior Gateway Protocol)"></a>内部网关协议 IGP (Interior Gateway Protocol)</h2><p>在一个自治系统内部使用的路由选择协议。 如 RIP 和 OSPF 协议。</p><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>RIP 是一种分布式的、基于距离向量的路由选择协议。</p><p>RIP 允许一条路径最多只能包含 15 个路由器。<br>“距离”的最大值为 16 时即相当于不可达。可见 RIP 只适用于小型互联网。<br>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。    </p><p>相邻路由器交换自己的全部信息，按固定时间交换信息，例如每隔30秒，RIP的收敛速度较快。<br><code>路由表更新算法</code><br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/RIP%E6%9B%B4%E6%96%B0.png" alt="路由表更新算法"><br><code>RIP 协议特点：好消息传播得快，坏消息传播得慢。</code>   </p><p>优点：</p><ol><li>实现简单，开销较小。</li></ol><p>缺点：</p><ol><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 </li><li>“坏消息传播得慢”，使更新过程的收敛时间过长。</li></ol><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>开放最短路径优先 OSPF (Open Shortest Path First)OSPF 的原理很简单，但实现起来却较复杂。<br>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送链路状态信息。  </p><ul><li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。</li><li>这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。</li><li>OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。</li><li>OSPF 的更新过程收敛得快是其重要优点。</li></ul><p>OSPF 划分区域<br>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。<br>在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。</p><p>OSPF 直接用 IP 数据报传送<br>OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 </p><h2 id="外部网关协议-EGP-External-Gateway-Protocol"><a href="#外部网关协议-EGP-External-Gateway-Protocol" class="headerlink" title="外部网关协议 EGP (External Gateway Protocol)"></a>外部网关协议 EGP (External Gateway Protocol)</h2><p>使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。如BGP-4。 </p><p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人” (BGP speaker) 。<br>一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。 </p><p>BGP 交换路由信息</p><p>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。<br>使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。<br>使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站(neighbor)或对等站(peer) 。</p><p>BGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。<br>在 BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。 </p><p>路由器的主要作用是：</p><ul><li>连通不同的网络。</li><li>选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率，从而让网络系统发挥出更大的效益来。</li></ul><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="路由器结构"><br>路由器三种交换方法<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E6%B3%95.png" alt="路由器三种交换方法"></p><h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><h2 id="IPv6-的基本首部"><a href="#IPv6-的基本首部" class="headerlink" title="IPv6 的基本首部"></a>IPv6 的基本首部</h2><p>IPv6 将首部长度变为固定的 40 字节，称为基本首部。<br>把首部中不必要的功能取消了，使得 IPv6 首部的字段数减少到只有 8 个。<br>ipv6数据报格式<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/ipv6.png" alt="ipv6">   </p><h2 id="从-IPv4-向-IPv6-过渡"><a href="#从-IPv4-向-IPv6-过渡" class="headerlink" title="从 IPv4 向 IPv6 过渡"></a>从 IPv4 向 IPv6 过渡</h2><p>向 IPv6 过渡只能采用逐步演进的办法，同时，还必须使新安装的 IPv6 系统能够向后兼容：IPv6 系统必须能够接收和转发 IPv4 分组，并且能够为 IPv4 分组选择路由。</p><h3 id="使用双协议栈"><a href="#使用双协议栈" class="headerlink" title="使用双协议栈"></a>使用双协议栈</h3><ul><li>双协议栈 (dual stack) 是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有两个协议栈，一个 IPv4 和一个 IPv6。 </li><li>双协议栈的主机（或路由器）记为 IPv6/IPv4，表明它同时具有两种 IP 地址：一个 IPv6 地址和一个 IPv4 地址。</li><li>双协议栈主机在和 IPv6 主机通信时是采用 IPv6 地址，而和 IPv4 主机通信时就采用 IPv4 地址。</li><li>根据 DNS 返回的地址类型可以确定使用 IPv4 地址还是 IPv6 地址。</li></ul><h3 id="使用隧道技术"><a href="#使用隧道技术" class="headerlink" title="使用隧道技术"></a>使用隧道技术</h3><ul><li>在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4 数据报，整个的 IPv6 数据报变成了 IPv4 数据报的数据部分。</li><li>当 IPv4 数据报离开 IPv4 网络中的隧道时，再把数据部分（即原来的 IPv6 数据报）交给主机的 IPv6 协议栈。</li></ul><h2 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h2><ul><li>IPv6 也不保证数据报的可靠交付，因为互联网中的路由器可能会丢弃数据报。</li><li>因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。新的版本称为 ICMPv6。  </li></ul><p>地址解析协议 ARP 和网际组管理协议 IGMP 协议的功能都已被合并到 ICMPv6 中。</p><h1 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h1><p>IP 多播 (multicast，以前曾译为组播) 已成为互联网的一个热门课题。<br>目的：更好地支持一对多通信。<br>一对多通信：一个源点发送到许多个终点。<br>例如，实时信息的交付（如新闻、股市行情等），软件更新，交互式会议及其他多媒体通信。</p><p>多播路由选择协议在转发多播数据报时使用三种方法：<br>(1) 洪泛与剪除<br>(2) 隧道技术 (tunneling)<br>(3) 基于核心的发现技术</p><h1 id="虚拟专用网-VPN-和网络地址转换-NAT"><a href="#虚拟专用网-VPN-和网络地址转换-NAT" class="headerlink" title="虚拟专用网 VPN 和网络地址转换 NAT"></a>虚拟专用网 VPN 和网络地址转换 NAT</h1><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/%E4%B8%89%E4%B8%AA%E4%B8%93%E7%94%A8%20IP%20%E5%9C%B0%E5%9D%80%E5%9D%97png.png" alt="三个专用 IP 地址块">   </p><h2 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h2><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="网络地址转换的过程">  </p>]]></content>
      
      
      <categories>
          
          <category> networks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——4.运输层</title>
      <link href="/2021/07/26/networks/4/"/>
      <url>/2021/07/26/networks/4/</url>
      
        <content type="html"><![CDATA[<h1 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h1><p>它属于面向通信部分的最高层，同时也是用户功能中的最低层。<br>从IP层来说，通信的两端是两台主机。<br>从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。<br>运输层向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。<br><code>户数据报协议 UDP (User Datagram Protocol)</code>:辑通信信道就相当于一条全双工的可靠信道。<br><code>传输控制协议 TCP (Transmission Control Protocol)</code>:辑通信信道是一条不可靠信道。<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/tcp/tcp_udp.png" alt="tcp_udp"></p><h1 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h1><p>UDP 只在 IP 的数据报服务之上增加了很少一点的<br>功能：   </p><ul><li>复用和分用的功能   </li><li>差错检测的功能</li></ul><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</p><ul><li>UDP 是无连接的</li><li>UDP 使用尽最大努力交付</li><li>UDP 是面向报文的</li><li>UDP 没有拥塞控制</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li><li>UDP 的首部开销小<h2 id="UDP-的首部格式"><a href="#UDP-的首部格式" class="headerlink" title="UDP 的首部格式"></a>UDP 的首部格式</h2><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/tcp/udp.png" alt="udp"><br>检验和求和取反码</li></ul><h1 id="传输控制协议-TCP-概述"><a href="#传输控制协议-TCP-概述" class="headerlink" title="传输控制协议 TCP 概述"></a>传输控制协议 TCP 概述</h1><p><code>套接字 socket = (IP地址 : 端口号)  </code><br><code>TCP 连接 ::= &#123;socket1, socket2&#125; = &#123;(IP1: port1)，(IP2: port2)&#125;  </code></p><h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><h2 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h2><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p><ol><li>无差错情况<br> A 发送分组 M1，发完就暂停发送，等待 B 的确认 (ACK)。B 收到了 M1 向 A 发送  ACK。A 在收到了对 M1 的确认后，就再发送下一个分组  M2。</li><li>出现差错<br> 在接收方 B 会出现两种情况：<br>B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。<br>M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。<br>A然后超时重传</li><li>确认丢失和确认迟到<br>若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1。</li></ol><p>自动重传请求 ARQ<br>停止等待协议的优点是简单，缺点是信道利用率太低。<br>在收到确认之前，发送方连续发出多个分组，流水线传输可提高信道利用率</p><p>停止等待协议要点</p><ul><li>停止等待</li><li>编号</li><li>自动重传请求</li><li>简单</li></ul><h2 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h2><p>基本思想：<br>发送方一次可以发出多个分组。<br>使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号。<br>每收到一个确认，发送方就把发送窗口向前滑动。<br>接收方一般采用累积确认的方式。<br>采用回退N（Go-Back-N）方法进行重传。<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/tcp/ARQ_stop.png" alt="[ARQ_stop]"></p><h1 id="TCP-报文段的首部格式"><a href="#TCP-报文段的首部格式" class="headerlink" title="TCP 报文段的首部格式"></a>TCP 报文段的首部格式</h1><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/tcp/tcp.png" alt="tcp"><br>侵删～～～  以下内容来源<a href="https://www.cnblogs.com/feng9exe/p/8058891.html">TCP报文格式详解</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1、端口号：用来标识同一台计算机的不同的应用进程。</span><br><span class="line"></span><br><span class="line">1）源端口：源端口和IP地址的作用是标识报文的返回地址。</span><br><span class="line"></span><br><span class="line">2）目的端口：端口指明接收方计算机上的应用程序接口。</span><br><span class="line"></span><br><span class="line">TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。</span><br><span class="line"></span><br><span class="line">2、序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。</span><br><span class="line"></span><br><span class="line">3、数据偏移／首部长度：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。</span><br><span class="line"></span><br><span class="line">4、保留：为将来定义新的用途保留，现在一般置0。</span><br><span class="line"></span><br><span class="line">5、控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。</span><br><span class="line"></span><br><span class="line">1）URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。</span><br><span class="line"></span><br><span class="line">2）ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。</span><br><span class="line"></span><br><span class="line">3）PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。</span><br><span class="line"></span><br><span class="line">4）RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。</span><br><span class="line"></span><br><span class="line">5）SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。</span><br><span class="line"></span><br><span class="line">6）FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</span><br><span class="line"></span><br><span class="line">6、窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。</span><br><span class="line"></span><br><span class="line">7、校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。</span><br><span class="line"></span><br><span class="line">8、紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</span><br><span class="line"></span><br><span class="line">9、选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。</span><br><span class="line"></span><br><span class="line">10、数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</span><br></pre></td></tr></table></figure><p><code>为什么要规定 MSS ？</code><br>若选择较小的 MSS 长度，网络的利用率就降低。<br>若 TCP 报文段非常长，那么在 IP 层传输时就有可能要分解成多个短数据报片。会使开销增大</p><h1 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h1><h2 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h2><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/tcp/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" alt="滑动窗口"><br>发送缓存用来暂时存放：<br>发送应用程序传送给发送方 TCP 准备发送的数据；<br>TCP 已发送出但尚未收到确认的数据。<br>接收缓存用来暂时存放：<br>按序到达的、但尚未被接收应用程序读取的数据；<br>不按序到达的数据。 </p><h2 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h2><p>这个自己去看书吧，就是几个公式，很好算的</p><h2 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h2><p>只传送缺少的数据而不重传已经正确到达接收方的数据</p><h1 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h1><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/tcp/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt="流量控制"><br>死锁问题：<br>B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。<br>但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。<br>如果没有其他措施，这种互相等待的死锁局面将一直延续下去。<br>为了解决这个问题，TCP 为每一个连接设有一个持续计时器 (persistence timer)。<br>只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。<br>若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。<br>若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。<br>若窗口不是零，则死锁的僵局就可以打破了。</p><p>糊涂窗口综合症：每次仅发送一个字节或很少几个字节的数据时，有效数据传输效率变得很低的现象。<br>解决方法：让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。</p><h1 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h1><p>出现拥塞的原因：对资源需求  &gt; 可用资源<br>增加资源不能解决拥塞，还可能使网络的性能更坏。增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞；</p><p>拥塞控制与流量控制的区别<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/tcp/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="拥塞控制与流量控制的区别"></p><p><code>真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)</code></p><p>拥塞的判断:重传定时器超时</p><h2 id="四种拥塞控制算法（-RFC-5681）-："><a href="#四种拥塞控制算法（-RFC-5681）-：" class="headerlink" title="四种拥塞控制算法（ RFC 5681） ："></a>四种拥塞控制算法（ RFC 5681） ：</h2><ul><li>慢开始 (slow-start)</li><li>拥塞避免 (congestion avoidance)</li><li>快重传 (fast retransmit)</li><li>快恢复 (fast recovery)<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/tcp/cwnd.png" alt="cwnd"></li></ul><h2 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h2><p>随机早期检测 RED (Random Early Detection)。<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/tcp/RED.png" alt="RED"></p><h1 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h1><p>TCP 连接有三个阶段：<br>连接建立<br>数据传送<br>连接释放<br>TCP 连接的建立采用客户服务器方式。<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/tcp/tcp_connect.png" alt="tcp_connect"><br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/tcp/tcp_close.png" alt="tcp_close"></p>]]></content>
      
      
      <categories>
          
          <category> networks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——5.应用层</title>
      <link href="/2021/07/26/networks/5/"/>
      <url>/2021/07/26/networks/5/</url>
      
        <content type="html"><![CDATA[<h1 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h1><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/usage/%E5%9F%9F%E5%90%8D%E7%A9%BA%E9%97%B4%20.png" alt="域名空间">  </p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><ul><li>根域名服务器<br>  根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。<br>不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。<br>在互联网上共有 13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从 a  一直到 m（前 13 个字母）。   a.rootservers.net</li></ul><ul><li>顶级域名服务器<br>  顶级域名服务器（即 TLD 服务器）负责管理在该顶级域名服务器注册的所有二级域名。<br>当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。 </li></ul><ul><li><p>权限域名服务器<br>  负责一个区的域名服务器。<br>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。 </p></li><li><p>本地域名服务器<br>本地域名服务器对域名系统非常重要。<br>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。<br>每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，<br>这种域名服务器有时也称为默认域名服务器。</p></li></ul><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>主机向本地域名服务器的查询一般都是采用递归查询<br>本地域名服务器向根域名服务器的查询通常是采用迭代查询<br>本地域名服务器采用递归查询（比较少用）   </p><ul><li>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。</li><li>可大大减轻根域名服务器的负荷，使互联网上的 DNS 查询请求和回答报文的数量大为减少。 </li><li>为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时<br>器，并处理超过合理时间的项（例如，每个项目只存放两天）。</li><li>当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名转换的准确性。<h1 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h1><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口 (21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。<br>接着，服务器进程用自己传送数据的熟知端口 (20) 与客户进程所提供的端口号码建立数据传送连接。<br>由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。<h2 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h2>其熟知端口号码为  69<br>TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。<br>TFTP 的工作很像停止等待协议</li></ul><h1 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h1><p>TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机则运行 TELNET 服务器进程。<br>和 FTP 的情况相似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。 </p><h1 id="万维网-WWW"><a href="#万维网-WWW" class="headerlink" title="万维网 WWW"></a>万维网 WWW</h1><p>万维网以客户 - 服务器方式工作。<br>浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。</p><ul><li>使用统一资源定位符 URL (Uniform Resource Locator) 来标志万维网上的各种文档。</li><li> 用超文本传送协议 HTTP (HyperText Transfer Protocol)实现万维网上各种超链的链接</li><li> 超文本标记语言 HTML (HyperText Markup Language) 使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到互联网上的任何一个万维网页面</li></ul><p>持续连接的两种工作方式<br>非流水线方式，流水线方式</p><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><h2 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构"></a>http报文结构</h2><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/usage/http_get.png" alt="http_get"><br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/usage/http_res.png" alt="http_res">   </p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>万维网站点可以使用 Cookie 来跟踪用户。<br>Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。<br>使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。 </p><p>垂直搜索引擎 (Vertical Search Engine) 针对某一特定领域、特定人群或某一特定需求提供搜索服务。</p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/usage/email.png" alt="email"><br>电子邮件地址的格式<br>:收件人邮箱名@邮箱所在主机的域名<br>SMTP 通信的三个阶段:连接建立,邮件传送,连接释放</p><p>pop3和imap<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/usage/pop3_imap.png" alt="pop3_imap">   </p><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/usage/www_email.png" alt="www_email"></p><h1 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h1><p>在协议软件中，给协议参数赋值的动作叫做协议配置。<br>一个协议软件在使用之前必须是已正确配置的。<br>连接到互联网的计算机的协议软件需要配置的参数包括：<br>IP 地址<br>子网掩码<br>默认路由器的 IP 地址<br>域名服务器的 IP 地址<br>DHCP 使用客户 - 服务器方式<br>DHCP 中继代理(relay agent) </p><p><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/usage/dhcp.png" alt="dhcp">   </p><h1 id="简单网络管理协议-SNMP"><a href="#简单网络管理协议-SNMP" class="headerlink" title="简单网络管理协议 SNMP"></a>简单网络管理协议 SNMP</h1><p>网络管理的五大功能</p><ul><li>故障管理：故障检测、隔离和纠正。</li><li>配置管理：初始化网络、并配置网络。</li><li>计费管理：记录网络资源的使用。</li><li>性能管理：估价系统资源的运行状况及通信效率等。</li><li>网络安全管理：对授权机制、访问控制、加密和加密关键字的管理</li></ul><p>简单网络管理协议 SNMP (Simple Network Management Protocol) 中的管理程序和代理程序按客户–服务器方式工作。<br>管理程序运行 SNMP 客户程序，向某个代理程序发出请求（或命令），代理程序运行 SNMP 服务器程序，返回响应（或执行某个动作）。<br>在网管系统中，往往是一个（或少数几个）客户程序与很多的服务器程序进行交互</p><h1 id="应用进程跨越网络的通信"><a href="#应用进程跨越网络的通信" class="headerlink" title="应用进程跨越网络的通信"></a>应用进程跨越网络的通信</h1><p>socket</p><h1 id="P2P-应用"><a href="#P2P-应用" class="headerlink" title="P2P 应用"></a>P2P 应用</h1><p>具有集中目录服务器的 P2P 工作方式Napster<br><img src="https://gitee.com/sellun/cnblog/raw/master/computerNetwork/usage/napster.png" alt="napster"><br>具有全分布式结构的 P2P 文件共享程序Gnutella</p>]]></content>
      
      
      <categories>
          
          <category> networks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo</title>
      <link href="/2019/05/03/hello-world/"/>
      <url>/2019/05/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hello </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
